**堆和栈有什么区别吗？**

栈由编译器自动管理，存放局部变量，函数参数和返回地址，遵循先进先出，分配和释放速度较快，但是空间有限,通常是操作系统在程序启动时为每个线程分配的固定大小一般是8MB；堆是由程序员或者内存管理器动态分配的，存放动态数据和大块数据，生命周期可跨函数调用，分配释放比较慢，但是空间较大。

要是追问那么堆的大小没有限制吗？虽然空间大，但是他的大小还是受可用内存和进程虚拟地址空间限制，要是堆耗尽会导致动态分配失败（malloc返回NULL)

**栈为什么比堆运行速度快**

- 申请速度快：栈是在编译时分配空间，堆是在运行时分配空间的
- 存储寻址速度快：栈的物理地址是连续的，但是堆的链表比较耗时
- cpu硬件操作速度快：cpu有专门的寄存器来操作栈，但是对于堆只能通过间接寻址

**你了解hash表吗，怎么样解决hash冲突？**

哈希表是一种通过哈希函数将数据映射到固定大小数组中的数据结构，可以实现快速查找。对于哈希冲突，解决方法有链式法和开放地址法。链式法通过在每个筒中使用链表存储冲突元素；开放地址法通过调整位置寻找空位来解决冲突

那么追问：他们分别有什么优点和缺点？

链式法的有点在于他可以通过链表动态扩展哈希表，适应存在大量冲突的情况下；缺点在于，因为需要额外存储指向链表的指针，所以内存开销大，并且在哈希冲突严重时，会使得查找速度退化成on,对于开放地址法，则没有额外的内存开销，适合内存受限的环境，但在冲突较多时，探测次数增加，负载因子过高时会导致性能下降

那么就是哈希表冲突太大的时候上面那两个都解决不了，那么应该怎么解决呢？

首先可以通过增大哈希表的容量来降低冲突发生的概率，其次可以通过选择河是的哈希函数使得能更加均匀的分配数据减少冲突；

那么提到了哈希的扩容，他是怎么扩容的 操作在新表还是旧表

当负载因子超过某个值时会触发哈希表的扩容，进行扩容时，哈希表的容量会翻倍。具体操作是这样的，首先他会创建一个新的哈希表，然后，将元表中所有数据通过哈希函数插入到新的哈希表中，旧表会被释放

小知识：负载因子：元素数量/哈希表容量

**你了解红黑数吗，他解决了什么问题？**

红黑数是一种自平衡的二叉查找树，通过给每个节点添加红色或黑色标记来保证平衡，确保在最坏的情况下查找，插入和删除操作的时间复杂度位o(logN),那主要解决了普通二叉树可能因为不平衡而退化成链表的问题，避免了性能的下降

**你了解跳表吗？**

跳表是一种带多层索引的有序链表，他通过在普通链表上增加多层“跳跃索引”来加快查找速度，不论是插入，删除来时查找的平均复杂度都能达到O(logn),而且实现和维护比红黑数简单，他的工作原理就是从最高层索引开始查找，能往前跳就跳，跳不动就往下一层，直到到达底层链表然后定位到目标节点。插入和删除除了更新最底层链表之外，还会根据随机策略决定在哪写索引层更新对应节点。他在redis的zset中也与用到



