**堆和栈有什么区别吗？**为什么要这么分区？

栈由编译器自动管理，存放局部变量，函数参数和返回地址，遵循先进先出，分配和释放速度较快，但是空间有限,通常是操作系统在程序启动时为每个线程分配的固定大小一般是8MB；堆是由程序员或者内存管理器动态分配的，存放动态数据和大块数据，生命周期可跨函数调用，分配释放比较慢，但是空间较大。

要是追问那么堆的大小没有限制吗？虽然空间大，但是他的大小还是受可用内存和进程虚拟地址空间限制，要是堆耗尽会导致动态分配失败（malloc返回NULL)

**栈为什么比堆运行速度快**

分配和释放效率高：栈内存时通过编译器管理的，入栈出栈只需要移动一下栈顶指针，而堆内存是在运行时通过malloc/new分配 

访问速度也比较快：栈空间在内存中时连续分配的，cpu缓存命中率高；而堆内存一般是离散分配的，可能会导致有更多的寻址

硬件支持：cpu有专门的寄存器来操作栈，访问栈变量可以通过偏移量直接寻址；而堆需要通过指针间接寻址，效率更低

栈的大小是固定的吗

为什么线程需要分配栈而不需要分配堆

**你了解hash表吗，怎么样解决hash冲突？**

哈希表是一种通过哈希函数将数据映射到固定大小数组中的数据结构，可以实现快速查找。对于哈希冲突，解决方法有链式法和开放地址法。链式法通过在每个筒中使用链表存储冲突元素；开放地址法通过调整位置寻找空位来解决冲突

那么追问：他们分别有什么优点和缺点？

链式法的有点在于他可以通过链表动态扩展哈希表，适应存在大量冲突的情况下；缺点在于，因为需要额外存储指向链表的指针，所以内存开销大，并且在哈希冲突严重时，会使得查找速度退化成on,对于开放地址法，则没有额外的内存开销，适合内存受限的环境，但在冲突较多时，探测次数增加，负载因子过高时会导致性能下降

那么就是哈希表冲突太大的时候上面那两个都解决不了，那么应该怎么解决呢？

首先可以通过增大哈希表的容量来降低冲突发生的概率，其次可以通过选择河是的哈希函数使得能更加均匀的分配数据减少冲突；

那么提到了哈希的扩容，他是怎么扩容的 操作在新表还是旧表

当负载因子超过某个值时会触发哈希表的扩容，进行扩容时，哈希表的容量会翻倍。具体操作是这样的，首先他会创建一个新的哈希表，然后，将元表中所有数据通过哈希函数插入到新的哈希表中，旧表会被释放

小知识：负载因子：元素数量/哈希表容量

**你了解红黑数吗，他解决了什么问题？**

红黑数是一种自平衡的二叉查找树，通过给每个节点添加红色或黑色标记来保证平衡，确保在最坏的情况下查找，插入和删除操作的时间复杂度位o(logN),那主要解决了普通二叉树可能因为不平衡而退化成链表的问题，避免了性能的下降

**你了解跳表吗？**

跳表是一种带多层索引的有序链表，他通过在普通链表上增加多层“跳跃索引”来加快查找速度，不论是插入，删除来时查找的平均复杂度都能达到O(logn),而且实现和维护比红黑数简单，他的工作原理就是从最高层索引开始查找，能往前跳就跳，跳不动就往下一层，直到到达底层链表然后定位到目标节点。插入和删除除了更新最底层链表之外，还会根据随机策略决定在哪写索引层更新对应节点。他在redis的zset中也与用到

堆排序，用优先队列，优先队列怎么实现的？我插入一个元素怎么变动的？

**json和protobuffer有什么区别**

json是文本格式，易读但是体积大，解析慢；protobuf是二进制格式，体积小，性能高，但是不可读，需要schema定义，因此json适合前端交互，protobuf更适合服务间高性能通信

protobuf详细

protobuf是goole开发的一种可以跨语言的高效的序列化协议；首先是schema定义，也就是.proto文件，他的每个字段都有一个编号tag,用来在二进制数据中标识字段；然后就是序列化过程，按字段号+类型编码成二进制，凡序列也是按照字段号+类型进行解析

ai:Protobuf 是 Google 开发的一种跨语言的高效序列化协议，它需要通过 `.proto` 文件来定义数据结构，每个字段都有一个唯一的编号，也就是 tag，用来在二进制数据中标识字段。序列化的时候，它会把数据编码成二进制格式，只存储 tag、类型和值，而不是字段名，所以相比 JSON 体积更小，解析速度也更快。比如整数会用 Varint 这种变长编码，小数字只占一个字节，字符串则用“长度+内容”的方式存储。反序列化时也按 tag 来解析，不认识的 tag 会被自动跳过，这就保证了向前兼容性。因为高效、省空间，Protobuf 常用于 gRPC、微服务之间的 RPC 通信、日志传输、IoT 等场景。

**微服务服务注册和发现的流程大概是什么样子**

他主要分为服务注册和服务发现两个过程：

服务注册：当一个服务实例启动的时候，他会把自己的信息比如说服务名,ip,端口等注册到服务注册中心，注册中西那会维护一张实时的服务实例表。而且他会定期对服务实例进行健康检查，要时发现某个实例宕机或者不可用了，就把他自动删除

服务发现：当一个服务需要调用另一个服务的时候，因为符合他想调用的服务很多，因此他不会将目标地址写死，而是向注册中心去查询

注意：都是针对客户端来说的

客户端发现：客户端自己去注册中心拉取服务列表，通过在本地负载均衡选择一个

服务端发现：客户端并不直接去注册中心进行查询，而是把请求发到一个固定的入口，让这个中间代理层去注册中心拉取服务列表进行负载均衡然后将结果返回个客户端

**HashMap是线程安全的吗？不安全的话怎么处理**

hashmap不是多线程安全的，要是多个线程同时修改同一个hashmap,就可能会导致数据错乱。要是主有一个线程写，其他的都是读，那么基本上是线程安全的。

解决方法：

加锁，在线程对公共hashmap进行操作的时候，对他进行加锁保证原子操作

有的语言中的map天然安全，向go语言中的sync.Map

**select B from ... where A = ? And C = ？,怎么索引优化**

首先这种做法叫做单列索引，他的操作步骤是首先他会在在B+树A的索引上找到满足所有key的的叶子结点，每个叶子节点都有对应行的主键，他会进行回表操作，然后在主表这个B+树中找叶子结点满足C的key，满足就返回

优化方式：联合索引，将A和B按照列的顺序让在一起，比如说是（A，C），他是这样进行查找的，因为A，B放在一起，那么他们会在一个B+树中，先按照顺序在树中找到A，然后在A下面找到相应的B，索引里已经包含了要查询的列，才能直接返回，否则还需要回表，要是不在，可以通过回表还获得C

**如果使用互斥锁来实现，一个线程访问，另外的线程是阻塞吗，可以不阻塞吗**

互斥锁的核心作用就是保证同一时间只有一个线程进入临界区，所以当一个线程持有锁，其他线程在访问同一临界取就会阻塞，知道持锁线程释放。

要是不想阻塞，可以使用阻塞读写锁

哪些高效的数据结构适合在内存种存储大量数据结构

哈希表，跳表

场景：验证用户密码【哈希表】；记录用户历史登录历史【跳表】

**布隆过滤器？**

他是一种用很小内存判断匀速是否可能存在和一定不存在的数据结构

细节：他主要包含一个长度为m的为数组，和k个独立的哈希函数；

对于要插入一个元素x，他会堆x阶段k个哈希值，分别把为数组对应位置设为1

在进行查询的时候，会先将x计算k个哈希值，要是通过&操作，要是所有对应为都是1,那就证明“可能存在”，要是只要有一位是0,那就一定不存在

- 布隆过滤器怎么修改数据？

**堆排序，快排，归并排序**





















1. 分布式锁怎么设计，利用什么组件

