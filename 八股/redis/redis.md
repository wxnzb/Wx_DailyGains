## redis
- **1:Redis和Memcached有什么区别和联系**
- ----------------------------------
共同点：

都是基于内存的数据库，一般当作缓存使用

都有过期策略

性能都很高

区别：

Redis支持的数据类型更丰富，有string,hash,list,set,zset等，但是memcached只有最简单的k-v

Redis支持持久化功能，可以将内存数据存入磁盘，重启可以从磁盘加载进行使用

Redis支持集群模式，但是memcached不支持

Resdis支持订阅模型，Lua脚本，事务等功能，但是memcached不支持

- -------------------------------------
**2:为什么Redis作为MySQL的缓存?**

Redis具备高性能和高并发

高性能体现：要使用户第一次访问MySQL数据，因为他存在磁盘，读取比较费时间，之后他就被缓存在redis中，下次要是继续读取这些数据，就直接从内存中读取，速度提高

高并发体现：直接访问Redis能承受的请求元元大于MySQL

**3：Redis是单线程的吗？**

Redis单线程指的是：从接收客户端请求->解析请求->进行读写操作->发送数据给客户端这一整个过程是由一个线程完成的

Redis在启动的时候，会启动后台线程

在2.6版本之前，是启动两个后台线程，处理关闭文件，aof刷盘

在4.o版本之后，又加了一个新的后台线程，异步释放Redis内存

有三个后台线程，他们相当于消费者，然后对redis的操作相当于生产者，那么就会三个队列，生产者方，消费者取

**4：Redis他不是将数据存放在内存吗，怎样实现数据不丢失？**

Redis会将数据持久化到磁盘

**5：那么Redis实现持久化的方式有哪些?**

AOF:每次执行写操作，就会将这个命令追加到文件

RDP快照：将某一时刻的数据以二进制的方式写到磁盘

但是好像在Redis4.0版本之后，就继承了AOF和RDP的优点

**6:Redis使用的过期删除策略是什么？**

Redis对key设置过期时间并将他放在过期字典里面，他有两种删除策略

惰性删除：他不主动删除过期健，每次访问数据库里面的key时都要检测他是否过期，要是过期就删除，但是这样的话就时要是不访问某些已经过期的key他就一直占用内存

定期删除：每个一段时间就随机取出固定数量的key检测他们是否过期，要是过期的key占的比例超过一定值就继续这个操作

**7：LRU算法和LFU算法有什么区别？**

Least Recently Used:

他底层使用的是链表，当操作元素时，这个链表就会像前移，所以要是要进行淘汰，就淘汰后面的，他的缺点，使用链表会带来额外的空间，而且将链表向前移的操作太费时间了

因此Redis进行了优化，他在一个Redis对向结构体添加一个字段：数据的最后访问时间，要是进行淘汰，他会随机选取对向，然后淘汰最久没用的那个---但是他也有缺点，就是应用要是一次读取大量数据，但是这些数据只被读取一次，那么他们回流在Redis缓存中很长时间，造成缓存污染

那么就引入了LFU

Least Frequently Used

他记录的是访问次数，访问次数少的将会被淘汰

**8：集群脑裂是什么意思？**

在Redis主从架构中，主节点负责写，从节点负责读，主节点既连接客户端又连接从节点。当主节点与从节点出现网络问题但是和客户端没有，那么继续可以接收客户端数据进行写，但是从节点们都以为主节点挂了，就在从节点中重新选择了一个把他当作主节点，但是现在第一个主节点与从节点之间的网络问题好了，那么现在就有两个主节点，这就是脑裂现象

**9：集群脑裂导致数据丢失怎么办？**

现状：那么哨兵已经选出了新的主节点，原来那个就会成为从节点，从节点会像新的主节点请求数据同步，第一次时全复制，那么他之前写入的数据就丢了

解决：当主节点发现节点下线或者通信超时的总数量小于固定值，那么禁止主节点进行写数据，要是又一定数量的从节点和主节点锻炼或者从节点从主节点读的时候书监超时那么主节点就不能和客户端进行交互了

**10：Redis怎样实现服务高可用？**

主从复制，哨兵模式，切片集群

哨兵模式：监控主从服务器，并且提供主从节点故障转移的功能

切片集群模式：Redis缓存数量太大，一台机子已经承受不了了，就会将数据进行接片，分配到不同的服务器上面

**redis的aof持久化：**

客户端在发送写命令时，redis会执行写命令，并将命令记录到硬盘【读命令是不会被记录到硬盘的】，他的持久化方法的潜在风险：

第一个是在redis执行完数据之后，还没有将他写入到营盘中，redis就宕机了，那么就可能存在数据丢失的情况

第二个是他在执行完写操作之后才会将命令写入硬盘，他却是不会阻塞当前的写操作，但是可能会阻塞下一个命令的执行

为了解决这个问题，redis在执行完写操作后，会将命令追加打破server.aof_buf缓冲区，然后通过write系统调用，将aof_buf缓冲区的数据写入到aof文件，此时数据并没有写入到硬盘，而是写入到了内核缓冲区，等待内核将数据写入硬盘

为什么redis是先执行命令在将他存在硬盘里面？

第一防止命令语法本来就有问题，要是不进行命令语言检查就直接将他存到硬盘，redis在恢复数据的时候，可能会出错

第二个好处，不会阻塞当前写操作命令的执行

那么aof的写操作一致追加到aof文件里，那么文件的大小会越来越大，那么要是重启redis的时候，读取aof文件恢复数据那得多满鸭，因此就引入了aof重写机制，他就是当aof文件的大小到达了一个阈值的时候，redis会fork一个子进程，父进程继续处理客户端请求，要是在次进程重新期间有新的数据，父进程会将命令加入到旧的aof文件【（保证原文件可用，万一重写失败也不影响恢复）】以及aof重写缓冲区，子进程就负责遍历内存里的数据，把每个 key 的最新状态写成一组最简化的命令，生成一个新的 AOF 文件，当子进程更新完毕之后，会通知父进程，父进程将重写缓冲区累积的新命令追加到子进程的aof文件里面，然后用子进程里面的新的aof文件代替旧的aof文件

**redis的主从复制：**

它主要分为两种模式，同步复制和增量复制

从节点刚上线，会向主节点发送PSYNC命令请求全量复制，主节点生成rdb快照发送给从节点，从节点接收到快速和主节点状态同步，之后每个主节点维护了一个复制缓冲区，每次有请求时，主节点会将命令放在复制缓冲区，然后从节点从复制缓冲区去数据，要是从节点短暂的出现了宕机然后恢复，可以通过复制缓冲区获取期间的增量命令