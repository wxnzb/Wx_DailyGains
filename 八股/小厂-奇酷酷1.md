小厂-奇酷酷1

go的八股：

说一下数组和切片的区别？

数组在go语言里面其实用的比较少，长度一旦定义就固定，还有go的数组是值类型，不像c语言的数组他底层是指向数组的第一个元素的指针，所以在go中赋值或者传参还会整体拷贝，效率和灵活性都不高；而切片就用的多了，他是动态数组，本质上切片是一个三元组，指针指向底层数组，当前数组长度len,容量cap,他是引用语义，传参不会复制底层数组，而且还能按需扩容，在cap不够用时，他会通过append函数进行追加。

那么他可能问你，go的扩容机制是怎么实现的，你怎么回答？

调用append函数进行元素的追加

在现用数组长度+新增元素<=总容量，那么内部直接relice不会创建新数组；要是大于，那么说明底层数组不够用了，一般会创建一个是原来2倍大小的数组(Go 1.18 之后会根据增长策略动态调整)，然后把元数组的内容复制进去

那么他可能继续问你，要是slice底层数组特别大，但是只需要很小的一部分，这种情况可能会导致什么，怎样解决？

那你讲一下go 1.18之后他是怎样实现动态扩容的？

在1.17之前，cap<1024直接翻倍，不然就每次增加每次%25,在go 语言的 1.18之后，他不是以1024为界限，而是以256为界限的，这样避免了大切片突然翻倍导致的内存浪费，同时保证小切片扩容依然高效。

因为底层数组还被引用着，他会导致GC无法回收未用到的大部分内存。解决方法：通过copy到新的slice来释放原始大数组的引用，避免占用过多内存

数组和链表的区别？

interface

channel

小厂-奇酷酷2

主要问了os的项目

问了内存管理的实现

为什么要把一页分为4kb

你觉得go语言和c语言有什么区别？

你在什么项目中用到了socket,socket出现了什么事故？

吴希，你是最棒的，加油！！！！

你的mq是怎样实现高可用高可用性的？

首先raft的多数派原则保证只要超过一般节点存活，集群就继续工作，即使leader宕机，follower会在超时后自动发起选举，快速完成新的leader,完成自动故障转移；其次，数据写入时必须复制到多数派节点才算提交，这样可以保证即使少数节点当即，数据也不会丢失，新leader仍然可以提供服务。

你的mq是怎么实现强一致性的？

raft的一致性问题可以分成3个子问题，分别是leader选举，日志同步和安全性保证。对于leader选举，leader会定时向follower发送心跳，follower内部会维护一个随机超时时间的定时器，当在定时器超时之前收到来自leader的心跳，会将定时器时间置0并继续保持follower状态,要是在定时器超时没有收到来自leader的心跳，那么follower会认为leader宕机，follower会变成竞选者，然后follower会将自己的term+1,向其他follower发送自己想成为leader的请求，携带自己日志的term和index,其他follower进行检查，看是否他的term比自己的大，要是一样，就继续比较最后一条日志的term和index,要是满足投票条件，follower会向候选者发送投票，要是收到超过一半follower的同意，那么他就会成为leader并通知下面的follower自己成为了leader.对于日志同步，Leader将客户端请求加入到自己的日志中，然后并行向其他follower发送请求，其他follower将请求写入自己的日志之后并给leader回复自己已经复制，当leader接收到超过一半follower已经进行复制，那么这条日志会被标记为commit,接着他会执行这个请求并将执行结果返回给客户端；然后就是安全性保障，raft的多数投票规则，提交规则保证了raft的安全，他又两点，已经commit的消息一定会存在在后续leader节点中，但是没有commit的消息，就可能会丢失

etcd在raft上的优化

k8s:

> “Kubernetes 由控制平面和节点层两部分组成。
>  控制平面包括：
>
> - **apiserver**：集群入口，提供统一 API；
> - **etcd**：状态存储，负责持久化集群元数据；
> - **controller-manager**：运行各种控制循环，确保集群状态一致；
> - **scheduler**：为 Pod 选择最优节点；
>    节点层包括：
> - **kubelet**：负责 Pod 生命周期和状态上报；
> - **kube-proxy**：实现 Service 的负载均衡与转发；
> - **container runtime**：运行容器。
>    整个系统通过 apiserver 交互，controller 循环调谐 Desired 与 Actual 状态，实现了声明式、可扩展、自愈的分布式控制系统。”

