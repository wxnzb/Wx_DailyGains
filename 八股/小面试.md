你写过os,那你了解编译原理吗，你在你的os中用到os了吗？

你了解系统调用吗，你在你的os中是怎样实现你的系统调用的？整个流程是怎样的？

系统调用是操作系统提供给用户态访问内核态功能的接口，像是read,write,execve等，他的本质是用户态通过syscall指令陷入内核态，内核态根据系统调用号找到对应的内核函数来完成操作，然后将结果然会给用户态。

我的系统调用是采用中断门机制，逊则ox80中断号作为系统调用入口，具体实现就是在中断描述符表中加入0x80这个中断号以及将DPL设置成3并将统一的系统调用入口函数传入到中断描述符表,也就是允许用户态调用，我的系统调用最大支持三个参数，通过宏实现将参数存入寄存器中，eax存放系统调用号，ebx,ecx,edx分别存放三个参数。用户态执行0x80时，cpu会在中断描述符表中找到0x80中断描述符，自动进行特权级切换，保存用户态上下文，跳转到系统调用入口函数，在根据传入的系统调用好，在系统调用表中找到这个系统调用号对应的系统调用函数去执行，执行完毕恢复上下文返回用户态，对于目前我的os,我实现的系统调用函数有getpid,write,malloc,free

什么时候用进程，什么时候用线程

我感觉这个还是要从他们的本质区别上面说起，进程他是有独立的内存空间，对于那些需要请隔离的安全性要求高的就可以用进程，一个进程的崩溃也不会影响其他的进程；还有就是cpu密集型的。线程他时共享内存的，他的创建和销毁开销低，对于那些需要频繁共享内存的任务可以用线程，还有就是i.o密集型的

你了解并发的含义？/并行

一个进程可以创建多少个线程？

一个进程能创建多少个线程这个我也不能确定，但他肯定不是可以无限创建的。因为虽然线程时共享内存的形式，但是每个线程都要有自己的栈的寄存器，那么能创建线程的数量大小我认为取决于内存大小，创建的线程的栈的大小以及操作系统对线程的限制等

线程同步方式？

互斥锁；自旋锁；读写锁；条件变量；屏障；信号量

互斥锁：在访问共享资源是对互斥量进行加锁，保证在访问共享变量的时候保持唯一性，他在等待获取锁的时候会进行足色，不占用cpu资源

自旋锁：自旋锁也是差不多，但是他在获取被占用的锁时他不会处于阻塞状态，而是仍然占用cpu资源，适合锁持有时间很短的场景，因为它不会让线程阻塞，而是循环等待

读写锁：对于对共享资源的访问，以读的模式则可以共享也就是多个线程进行访问；写的米时则需要以读占的形式，适合与读的操作远大于写

条件变量：配合互斥锁使用，等待某个条件成立再继续，比如生产者-消费者。

屏障：屏障就是让所有线程到达一个点后统一进行执行操作

信号量：信号量本质上是一个计数器，在同步方面时用他一般将他设置成0,先进行写操作会占用锁，那么会使信号量减1变成-1，然后读操作此时堵塞，直到写操作释放锁变成0后读操作可以继续。当信号量 > 0 时，线程获取资源并让它减 1；如果 = 0，则线程阻塞等待

读写锁，自旋锁，这些锁，

你了解io多路复用

timewait等待时间

tcp和http的keepalive

tcp的ack和序列号

tcp的优化方法

tcp的粘包和拆包

为什么会产生粘包问题

send和write连续调用会产生什么问题

redis怎么做分布式锁

分布式锁的概念：控制分布式系统不同进程访问共享资源的一种锁的实现。

过期时间：过期时间只是说明锁会被其他客户端哪走，但是不影响之前客户端后面的操作

首先为了避免多个客户端同时操作同一个数据，需要进行加锁，获取锁的客户端可以对数据进行操作，其他则需要等待，但是这样就会出现一个问题，就是要是获取锁的客户端在进行操作时突然当即了，那么此时其他客户端人然获取不了锁，就出现了死锁的问题；为了解决这个问题，就需要为加锁加过期时间这一原子操作，一到过期时间，要给下一个客户端获取锁，但是这样还有一个问题，就是要是在拿锁的a客户端到达了客户端，b把锁获取走了，此时a客户端后面的操作是释放锁，那不就是把b现在持有的锁进行删除了，为了防止这种锁勿删操作，那么就给锁一个唯一标识，以百年可以是客户端id,在释放时看这个锁的value是否是自己客户端id,要是是，才能进行释放，当锁被其他客户端获取，此时锁的value就变成其他客户端的id了，那么肯定就释放不了了。目前这些已经解决了主要问题，redis还对分布式锁进行了优化，就是，要是一个客户端一直在进行操作，但是到了过期时间，但是他还想继续操作时间(你不时说到了过期时间还是可以后续造作的马，这里怎么又说不行了?)，那么就引入了watchdog看门狗机制，也就是客户端在持有锁期间会不断进行刷新锁的过起事件，知道他把业务操作完成

你了解公平锁吗，非公平锁有哪些

redis的io多读复用

Redis 使用 I/O 多路复用（如 epoll）和非阻塞 socket，一个线程监听所有客户端连接。当 socket 上有读或写事件触发时，事件循环会让单线程去处理请求和响应。这样既能同时管理上万个连接，又避免了线程切换和锁竞争，是 Redis 单线程高性能的关键

raft按照什么实现快照触发的？条数？时间？

你mq中用到batch和pipeline?

mq中leaderbroker宕机了partition正在发生迁移生产者还在法消息怎么保证消息不丢失

一致性哈希发生数据迁移时怎么半

git的rebase和merge

merge是把两个分支的最后进行合并操作，生成一个新的合并提交，他可以回退到任何版本；但是rebase，就会将一个分支链放到量一个分支链上面

ai:`merge` 是把两个分支的改动合并，生成一个新的 merge commit，保留完整的分支历史。`rebase` 是把一个分支的提交‘挪到’另一个分支的最新提交之后，让历史看起来更干净直线，但会改写提交历史，所以一般只在本地分支用，不建议对公共分支 rebase。

















































