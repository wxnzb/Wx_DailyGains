**面对高并发场景，如何做到服务器不被冲垮**

首先可以从流量入口控制请求量

1：可以通过令牌桶或者漏桶在应用层进行限流操作，比如说秒杀场景，令牌桶或者漏桶限制每秒一百个请求，要是超过一百个请求就直接应用层返回排队中

2：降级：对于突发流量开启降级，应用层直接返回“排队中”

2：可以加入消息队列，请求先写入消息队列，后端服务器根据自己的消费能力异步拿取请求，起到了一定的缓冲能力

其次可以通过系统扩容：

可以加入分布式，也就是水平扩展多台服务器来分但压力，然后通过负载均衡等算法将请求分发到多台服务器上面；

也可以时用k8s集群，通过容器化部署扩展

ai:

面对高并发场景，防止服务器被冲垮，核心是从流量控制和系统扩容两方面入手：

首先是流量入口控制请求量：

1. **限流**：用令牌桶或漏桶算法在应用层限流 —— 秒杀场景适合令牌桶（允许短期突发流量，比如每秒基础 100 个请求，累积令牌应对峰值），超过阈值的请求直接返回 “排队中”；如果需要严格匀速处理，漏桶更合适，避免后端压力波动。
2. **降级**：优先保障核心功能（如支付、下单），非核心功能（如评论、推荐）降级为返回缓存数据或直接关闭，比如突发流量时，关闭 “猜你喜欢” 推荐，只保留商品基础信息展示。
3. **消息队列缓冲**：请求先写入消息队列（如 Kafka），前端无需等待后端处理，直接返回 “处理中”；后端服务按自身能力（如每秒 500 单）异步消费，既削峰填谷，又解耦前后端，避免同步阻塞。

其次是系统扩容提升承载能力：

1. **水平扩展**：部署多台服务器，通过负载均衡（如 Nginx 的轮询、一致性哈希）分发请求 —— 普通请求用轮询平均分担压力，热点用户请求用一致性哈希固定到某台服务器，减少缓存失效。
2. **容器化动态扩容**：用 K8s 集群部署，根据 CPU 使用率、请求量等指标自动扩缩容（比如流量高峰时从 10 台实例扩容到 100 台），流量低谷时自动缩容节省资源，实现弹性应对。

**模糊查询算法：**模糊查询算法用于在字符串不完全匹配的时候，快速找到相似的结果，主要是通过近似匹配解决输入不精确比如说拼写错误，部分匹配。

算法：

1：

编辑距离算法：

比如说目标字符串是apple,但是用户输入appel,编辑距离为1【交换“e"和"l",可以看错是一次交换】，因此判定为相似结果

或者用户输入app,那么编辑距离为2【需要插入l和e】，也会被纳入候选结果

细节：可以设置最大距离阈值过滤，小于阈值的保留

2：

前缀树+模糊匹配

前缀树中存储“apple""apply""applet"，那么当用户输入"appl"的时候，那么少了一个最后一个字符，那么他会从根节点遍历，发现后续分支有“e","y""e+t",因此返回“apple""apply""applet"

3：n-gram算法；

核心：将字符传拆分成连续为n的字符片段，通过判断片段的重叠度来判断相似度

比如说n=2,将背景天安门，拆成背，景，天，安，门，背景，景天，天安，安门

要是现在用户输入背景天an门，那么将他拆分发现有很多和上面的都是重叠字段，通过计算重叠比例还判定是否相似

4：通配符匹配+倒排索引

比如将*代表任意字符，？代表单个字符通过这些来表示模糊规则，结合倒排索引快速筛选结果

比如数据库有学生，学校，用户查询学，那么会通过倒排索引返回学校和学生

比如*.txt的所有文件，还有sql语句like%...%

- 短字符串（如单词、关键词）用**编辑距离**或**前缀树**（精度高、速度快）；
- 长文本或不规范输入用**n-gram**（抗干扰性强）；
- 规则明确的模糊场景（如带通配符）用**倒排索引 + 通配符匹配**（效率高）。

**golang的切片扩容机制**

结构：

切片是数组的封装，底层主要是由三部分组成：低向底层起始地址的指针，当前切片中元素的数量len,底层数组的总容量cap

当切片的len=cap的时候，在向切片中添加元素【append】就会触发扩容

扩容步骤：

计算新的容量cap,分配一块容量为cap的新数组，将旧数组中的元素复制到新数组中，切片的指针指向新数组，len和cap都进行更新

我记得go的1.18版本对他做了优化，要是旧cap<256,那么在触发扩容的时候，会直接将新cap赋值为旧cap的两倍；要是他是>256,那么触发扩容基址的时候会每次增加原来旧cap的25%,确保高效利用内存

还有一个消息接：在计算出新的cap后，一般还需要根据go额内存对齐规则进行调整。

注意：

1. **“新 cap 的兜底规则”**：当按 “翻倍” 或 “+25%” 计算出的新 cap 仍小于实际需要的最小容量（即`新增元素后的总长度newLen`）时，会直接用`newLen`作为新 cap。比如旧 cap=10（<256），但一次添加 20 个元素（newLen=30），此时按翻倍算新 cap=20 不够，会直接取 30 作为新 cap。

   

数据库锁的实现

**联合索引和单列索引的区别：**

定义：单列索引只是针对表中单个字段创建的索引，联合索引是对表中的多个字段组合创建的索引，索引结构是按照字段顺序存储组合值

适合查询：单列索引主要针对单一列的查询；联合索引：针对同时涉及多个列的查询

索引利用情况：每次查询只能利用一个索引；要是查询满足最左匹配原则，可以同时利用索引中的多个列

效率：单列查询在单列查询中效率高，在设计多个列的查询，一般比多个单列索引查询效率高，主要是他减少了回表查询的次数

占用空间：单列索引占用空间想对少，联合索引一般占用空间大

**为什么用raedis实现点赞等功能而不是数据库**

1：点赞是一个高频操作，要求快速响应且可能每秒数十万次请求，redis是内存数据库，传统数据库mysql他是存储磁盘，内存比磁盘快，能轻松解决高量请求，满足高吞吐量

2：redis由高效数据结构非常适合点赞这一功能

set可以快速查找谁给这个文章点赞了，底层主要使用的是整数集合或者大一些就是hash

zset在上面的基础上实现了排序功能，可以给点赞排行榜用

补充：

要是使用数据库，会导致大量`insert/update`操作占用数据库连接，甚至引发锁竞争，影响订单、用户等核心业务的数据库性能。Redis 作为缓冲层能隔离高频操作，保护数据库。”

**回表**

回表是数据库查询中的一个操作过程：当我们通过二级索引（比如单列索引、联合索引）查询时，二级索引的 B + 树叶子节点只存储索引字段值和主键 ID，无法直接获取完整的行数据。这时候就需要用查到的主键 ID，去聚簇索引（主键索引）的 B + 树中再次查询，通过聚簇索引叶子节点存储的完整行数据，拿到最终需要的字段 —— 这个‘从二级索引到聚簇索引的二次查询过程’就叫回表

























