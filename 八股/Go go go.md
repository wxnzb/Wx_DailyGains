Go go go

**-------你了解go的内存逃逸吗？**

内存逃逸是指本应该分配在栈上的变量，被编译器分析后发现生命周期超过了栈的管理能力，编译器就会把他放在堆上，比如变量过大无法放在栈上，就会触发内存逃逸，因为堆上的内存需要GC扫描挥手，所以逃逸过对会增加GC压力，影响性能。

通过什么来看逃逸分析？

go build -gcflags=-m

**-------go的Gc机制：**

用的是并发的三色标记清除算法，主要分为标记和清除两个阶段，在标记阶段，他会把对向分为白色，灰色，黑色，对象最初都是白色，从根对象开始扫描，先变成灰色，等子对象都处理完后变成黑色，最后剩下的白色就是垃圾会被回收。标记阶段和用户程序是同时进行的，所以需要写屏障机制来保证安全，比如用户修改了指针，写屏障会把相关对象重新标记成灰色，避免勿回收。同时go的gc还会让携程协助gc完成标记，降低了stw的时间。go的Gc是追求低延迟，不追求高吞吐

**-------c++的map和go的有什么区别？**

C++的std::map底层是红黑树实现的有序关联容器，插入，删除，查找的时间复杂度是O(log n),遍历时可以保证顺序访问；如果是 `unordered_map`，它跟 Go 的 map 更接近，也是哈希表但是go的map底层是哈希表实现的，采用哈希通加拉链法来解决冲突，并通过增量扩容来提升性能，查找和插入的平均复杂度是O(1),但是kv是无序的，go的map默认并发不安全，需要配合锁使用。因为比较感兴趣，我看了一下gp实现map的源码，他的底层机构体时hmap,hmap结构表示一个哈希表，桶是bmap,里面存放的是tophash数组，overflow指针指向下一个桶，这个是以链表的形式将冲突哈希加入里面，Go 会把哈希值的低位用来决定落在哪个桶，高 8 位存在 `tophash`，用来加速桶内 key 的比较，所以查找和插入平均是 O(1)，但 key 是无序的。，在初始化map大小时，<8会调用makemap_small函数，>8的调用makemap函数，直接在堆上进行分配

**-------你能说一下go的channel吗？**

是go runtime实现的csp通信模型，底层是由hchan结构体实现的，这个结构体里面有四个重要的成员，环形缓冲队列，用来存放数据，sendx和revx指向环形缓冲队列发送的数据和接受的数据位置，以及sendq和revcq这两个等待发送队列和等待接收队列，和互斥锁。go的channel分为无缓冲channel和有缓冲channel,对于无缓冲channel,发送和接收必须同时发生。对于有缓冲channel,通过内部环形缓冲对列来解耦生产者和消费者，大概流程是这样，在环形缓冲区还有空位的时候，当发送者往环形缓冲区发送消息，首先会对环形缓冲区加锁，然后将要发送的数据copy到环形缓冲区，sendx++,然后在释放锁。只有在队列满或者空时才阻塞，在阻塞时为了提高性能，会和GMP搭配在一起使用，举个例子，对于发送方生产的太快或者接收方消费的太慢，那么环形缓冲对列满了，这时候runtime会检测到环形缓冲区满了，通知调度器，调度器会将发送者的状态改为waiting,此时会将发送者携程封装成一个sudog结构体，里面保存了channel相关的指针，从操作系统m中移除这个携程然后把sudog加入到sendq这个等待发送队列，然后从处理器的队列中取一个携程给操作系统线程并执行，这个时候就是之前发送消息的携程阻塞，但不是操作系统线程阻塞。当接收者从环形缓冲区接收一个数据时，会通知调度器，那么他会将发送者携程的状态由waiting变为runnable宁加入到处理器的队列里面。这是对于发送发阻塞的优化，对于接收者阻塞，那么他阻塞和前面差不多，但是当消费者向环形缓冲区发送数据的时候，也就是唤醒接收者时，他并不会去操作环形缓冲区，而是直接将发送者里面的数据copy到了接收者。

**-------csp的理念是什么？**

**-------你能说一下go的context 吗？**

**-------你了解go的GMP吗**

G是go协程，M是抽象出来的线程，P是处理器，用来调度G和M的关系

GMP原理是指携程只有被处理器放入操作系统线程中才能运行，处理器会周期性的把携程调度到操作系统线程上运行，每个处理器都有自己的本地队列，当某个处理器对应的本地队列空了，他就会去访问全局队列，从中取出携程丢给操作系统线程运行，当全局队列也没有携程时，这个处理器就会去其他处理器的本地队列中偷一部分携程

**-------为什么要有p?**

**-------你觉得go和c语言有什么区别，在什么情况下用哪个？**

**-------golang中make和new有什么区别马？**

1：作用类型不同，new作用范围更广，可以给任何类型分配内存，make时给sclice,map,channel分配内存

2：返回类型不同：new返回的是指向变量的指针，make返回变量类型本身

3：内存操作不一样：new分配空间后会将内存请清0,make分配空间后会进行内存初始化

**-------说一下数组和切片的区别？**

数组在go语言里面其实用的比较少，长度一旦定义就固定，还有go的数组是值类型，不像c语言的数组他底层是指向数组的第一个元素的指针，所以在go中赋值或者传参还会整体拷贝，效率和灵活性都不高；而切片就用的多了，他是动态数组，本质上切片是一个三元组，指针指向底层数组，当前数组长度len,容量cap,他是引用语义，传参不会复制底层数组，而且还能按需扩容，在cap不够用时，他会通过append函数进行追加。

那么他可能问你，go的扩容机制是怎么实现的，你怎么回答？

调用append函数进行元素的追加

在现用数组长度+新增元素<=总容量，那么内部直接relice不会创建新数组；要是大于，那么说明底层数组不够用了，一般会创建一个是原来2倍大小的数组(Go 1.18 之后会根据增长策略动态调整)，然后把元数组的内容复制进去

那么他可能继续问你，要是slice底层数组特别大，但是只需要很小的一部分，这种情况可能会导致什么，怎样解决？

那你讲一下go 1.18之后他是怎样实现动态扩容的？

在1.17之前，cap<1024直接翻倍，不然就每次增加每次%25,在go 语言的 1.18之后，他不是以1024为界限，而是以256为界限的，这样避免了大切片突然翻倍导致的内存浪费，同时保证小切片扩容依然高效。

因为底层数组还被引用着，他会导致GC无法回收未用到的大部分内存。解决方法：通过copy到新的slice来释放原始大数组的引用，避免占用过多内存

