TCP-看你能问个啥嘻嘻

**半连接队列(syn队列)和全连接队列(accept队列)**

服务端收到客户端发来的syn包后，会向客户端回复一个syn+sck,然后将这个连接信息放在半连接队列里面，当服务端收到客户端发来的ack是，就将这个连接信息从半连接队列里面删除并创建以的完全的连接放在全连接队列里面

**怎样优化tcp的连接？**

可以优化的点：tcp三次握手；tcp四次挥手；tcp数据传输

**三次握手阶段**

- **客户端优化**：调整 SYN 包的重传次数和重传间隔（比如 `tcp_syn_retries`），避免长时间等待；但过小会影响弱网环境下的连接成功率。
- **服务端优化**：
  - 调整半连接队列（`tcp_max_syn_backlog`）和全连接队列（`somaxconn`）大小，减少丢弃请求的情况。
  - 开启 **SYN Cookies**（`tcp_syncookies`），在半连接队列满时用算法生成 Cookie 放在 `SYN+ACK` 里返回，客户端回 ACK 时校验 Cookie，就能完成握手，而不占用半连接队列空间。
- **端口复用**：通过 `SO_REUSEADDR`/`SO_REUSEPORT` 提升高并发场景下服务端的连接处理能力。

**四次挥手阶段**

- 缩短 `TIME_WAIT`：比如开启 `tcp_tw_reuse`、`tcp_tw_recycle`（已废弃，常见于旧内核）来复用 TIME_WAIT 状态的 socket。
- 调整 `tcp_fin_timeout`，减少 FIN_WAIT2 状态持续时间。

**数据传输阶段**

- **滑动窗口 / 拥塞控制**：可以通过调整 `tcp_window_scaling`、拥塞算法（如 BBR、Cubic）来提升传输效率。

- **延迟确认**：合理配置 `tcp_delack_min` 等参数，平衡性能和延迟。

- **零拷贝**：应用层用 `sendfile`/`mmap` 等减少用户态和内核态拷贝，降低开销。

tcp三次握手：通过控制客户端重传次数来优化。客户端先向服务端发送syn包请求连接，要是在1秒内没收到，那么就会向服务端重新发送syn包，间隔的时间是以2的指数增长。要是在最后一次没有收到，那么客户端就会终止握手；服务器端对于半队列满和全队列满的情况会直接将新来的连接抛弃，我们可以通过写改内核数据里的半连接和全连接的最大值来使队列增大；但是要是连接的很快，还有开启fast open方法，客户端发送syn报文携带fast open,服务器回复sync+ack的包里面加上cookie,客户端收到后缓存cookie,下面要是发起http请求的时候戴上cookie就不需要进行三次握手了，直接传输数据就行。

tcp四次挥手：主动发送方优化：首先关闭方式有RST报文关闭和FIN报文关闭，对于RST报文关闭，就直接关闭连接了，不需要进行四次挥手，而FIN就保证了安全性，这下面又分为clise()关闭和shutdown关闭，对于close()调用，那他就不能读也不能写，比较倾向于释放资源，属于全双工；要是时shutdown你可以控制即使发送了FIN也可以读，或者可以写，属于半双工。要是遇到了恶意攻击，那么FIN报文根本呢就不会发送出去，原因：首先恶意报文将缓冲区占着，那么FIN报文就只能等待，还有就是攻击者下载大文件，设置接收窗口0,那么FIN报文也就发送不出去，那么就可以将关闭连接的方式设置成close,这样当故而连接超过一定值，新增的故而连接就步走四次挥手了，而是通过RST报文强行关闭。还有一种方式可以咋建立新连接的时候复用time-wait状态的连接，这个只对客户端有作用。

被动方优化：？感觉没说什么

因为一发在一收的方式以态传输，要是往不好就会导致传输很慢，但是要是批量进行传可能接收方收的速率跟不上，那么就出现了滑动窗口。接收方在发送给发送方包的时候会带上窗口字段，他是2字节，2的26次方大小，他查看自己的缓冲区，当接收到报文放进去后就会变小，read读取后就会变大；

那么现在会有个问题，就是是不是缓冲区设置的大，然后窗口大，那么发送速率就可以无先提高，那肯定不时的，因为网络传输是有限的，那么怎样确定最大传输速度？

**为什么主动发送关闭的一方在发送ack后还要变成time-wait状态等待2msl？**

1：防止主动关闭的一方发送的ack被动关闭方没有收到，那么被动方会向主动关闭方发送FIN，在次进行重试，要是这时候主动关闭方已经关闭连接了，那么无法保证被动关闭的一方能被正确的关闭

2：防止历史连接中的数据，被后面相同的4元组在新建立的连接错误的接收了。通过加上time-wait2msl,这个时间足以让两个方向上的数据包都被丢弃，时的原来连接的数据包在网络中都自然消失

那么为什么是2msl呢？

**1 MSL** 是一个方向上的最大发送+传播时间；

**2 MSL** 是为了覆盖**一个往返（发送 + 对方可能重发回来的）**过程，确保双方的所有旧报文都完全消失。

**那么timewait有什么问题，如何优化timewait?**

每个timewait都会占用一个本地端口和tcp控制快，当出现高并发短连接，会导致端口和内存资源被耗尽。

大量的time_wait状态会堆积在socket表中，增加系统管理开销

新连接可能会出现"address already in use"

**优化方式：**

对于客户端的短连接开启复用time_wait socket,提高连接重复率

也可以调整端口范围，扩大可用的临时端口，缓解端口耗尽的问题

也可以调整让服务器不主动关闭连接，把压力压到客户端

**tcp怎样解决粘包问题？**

udp他是面向报文的协议，操作系统不会对消息进行拆分，直接将udp报文放到队列里面，而tcp他是面向字节流，同一条消息可能被阶段到不同的报文里面，那么要向度去完整的消息，就要解决tcp粘包问题：

首先可以通过固定消息的长度，然后可以向http那样用特殊字符左边界；也可以自定义消息结构，消息结构题面包含着调消息的长度，后面就读取这些长度的消息即可



