既然你想把os当作主要项目,那你必须十分熟悉,不要幸运,只要努力

MBR → Loader → 内存探测 → A20 → GDT → 保护模式 → 加载内核 → 分页 → 内核启动

OS会问到的问题:

首先对os得有个整体熟悉,那你挑一个熟悉的项目展开讲一下:

My_OS项目是我比较感兴趣的一个项目,他是我根据操作系统真相还原这本书写的一个从0构建OS的项目,并在这个基础上面做了一些优化和扩展,整个项目他是主要用C语言和少量汇编语言编写,目前基本支持进程管理,内存管理,文件系统,终端处理这几个部分.我想详细讲一下我**实现这个项目的整个流程:**

整体完成代码步骤，mbr阶段，loader阶段，保护模式，分页机制的实现，内核初始化以及用户态。首先用汇编实现了只有512B内存的MBR,他主要负责初始化环境，加载loader到内存并跳转过去,！！那么需要用汇编实现loader.S,调用BIOS中断获得ARDS，计算出总物理内存给后面是用，然后从实模式进行保护模式，通过开启A20地址线,避免地址回绕让cpu能访问1MB以上的内存,然后构造GDT进入保护模式，他是构造GDT表并加载GDTR设置CR0寄存器的PE位为1,再用远跳转刷新流水线后就进入保护模式，进入保护模式之后立即建立安全的栈顶,设置CS/DS/SS等寄存器为平坦模式,然后加载内核文件，用LBA方式读磁盘把kernal.bin批量搬入内存(方法??)，既然进入了保护模式,那肯定需要开启分页机制，首先构造分页结构页目录和页表,让PDE[0]和PDE[768]指向同一张页表实现了恒等映射，实现了底端地址和内核高半区都可用，PDE[1023]实现自映射,设置完后开启分页(???),！！然后进入内核初始化阶段,首先关闭中断防止初始化过程被打断,然后重新设置GDT/IDT(？？？）,然后实现内存管理，他主要是通过在loader阶段得到的总物理内存减去内核占用区(1MB+页表占用部分1024*4字节 *2)得到可用物理内存后，将他平分为内核池和用户池，每个都拥有自己独立的位图,起始物理地址和锁,并通过管理位图来管理物理页，并设置了malloc_page页级分配和kmalloc小块内存分配，用来分配你需要的内存(通过分配虚拟页和并将虚拟页和物理页建立映射来实现，<1kb用arena拆分，否则直接按页来分配)，然后设置了中断子系统，注册了常见的中断服务，比如时钟中断，键盘中断等，然后设置了时钟和调度器，(初始化PIT,注册IRQ0处理函数，定义了PCB,采用时间片轮转调度，支持了线程切换，保存/恢复寄存器上下文！！初始化了系统调用，在IDT中设置了int 0x80中断门，DPL=3，用户态触发int 0x80进入内核，可执行系统服务，创建并启动了第一个内核线程，并创建了init用户态进程，加载用户程序，切换到用户态运行！！最终可进入shell,在用户态跑shell程序，实现了用户态通过键盘输入命令，shell解析并执行

**+++++++++++++++++++++++++++++++++++++++++++++++++++++++**

My_OS 项目是我比较感兴趣的一个项目，它是我根据《操作系统真相还原》这本书，从零构建的操作系统，并在此基础上做了一些优化和扩展。整个项目主要用 C 语言和少量汇编语言编写，目前基本支持进程管理、内存管理、文件系统和终端处理这几个部分。我想详细讲一下我实现这个项目的整个流程。

首先用汇编实现了引导区和加载器，在这个阶段完成了从 MBR 到 loader 的跳转和最基本环境初始化。MBR 只有 512B，主要负责设置段寄存器和栈，调用 BIOS 中断初始化磁盘参数，并把 loader 加载到内存，然后跳转过去。接下来在 loader 阶段，通过调用 BIOS 中断获得 ARDS 信息，计算总物理内存，并开启 A20 地址线，避免地址回绕，使 CPU 能访问 1MB 以上内存。然后构造 GDT 并加载 GDTR，将 CR0 的 PE 位置 1，通过远跳转刷新流水线后进入保护模式。进入保护模式后，立即建立安全的栈顶，保证堆栈受控，并设置 CS/DS/SS 等寄存器为平坦模式。接着使用 LBA 方式从磁盘读取 kernel.bin 批量加载到内存，通过设置 LBA 寄存器、发 0x20 命令、轮询 DRQ 并使用 insw 指令搬入数据，保证内核完整加载。

在进入保护模式之后，我实现了分页机制。首先构造页目录和页表，PDE[0] 和 PDE[768] 都指向同一张页表，实现底端地址和高半区内核同时可用，PDE[1023] 指向页目录自身，实现自映射，方便访问页表。然后加载 CR3 指向页目录物理地址，设置 CR0.PG=1 开启分页，保证内核在高半区可以正常访问内存。随后将 GDT 基址和视频段基址整体加上 0xC0000000，同时将 ESP 寄存器抬高到内核空间，进入内核入口。

进入内核后，我首先关闭中断以防初始化过程被打断，然后重新设置 GDT 和 IDT，初始化中断子系统，注册 CPU 异常、中断服务和系统调用入口，其中 int 0x80 设置 DPL=3 供用户态调用。接下来实现内存管理子系统，通过 loader 阶段获得的总物理内存减去内核占用（低 1MB + 页表部分）得到可用物理内存，再将其平分为内核池和用户池，每个池都有独立位图、起始物理地址和锁。通过自映射页表管理，page_table_add 先检查 PDE.p 是否存在，按需分配页表并清零，然后设置 PTE，实现虚拟页和物理页的映射。基于此实现 malloc_page 页级分配和 kmalloc 小块分配，小于 1KB 使用 arena 分拆，大于 1KB 按页分配，释放时通过刷新 TLB 回收内存。

然后初始化中断和调度器，设置时钟（PIT）和键盘中断，定义 PCB 并实现时间片轮转调度，支持线程切换，保存和恢复寄存器上下文。系统调用初始化完成后，用户态可以通过 int 0x80 调用内核服务。最后创建第一个内核线程，并创建 init 用户态进程，加载用户程序并切换到用户态运行，最终可以进入 shell，用户态通过键盘输入命令，shell 解析并执行，实现完整的用户交互。

**+++++++++++++++++++++++++++++++++++++++++++++++++++++++**

**机器开机启动后会怎样**

在计算机接电的一瞬间，CPU中的寄存器会被强制初始化到BIOS入口地址0xffff0,这个地址是只读ROM固化在硬盘中的BIOS程序，然后由他完成开机自检与启动的工作，BIOS程序会在磁盘的0盘0道1扇区找到mbr，mbr结束的标志是0x55和0xaa。但是因为一个磁盘的大小只有512字节，所以它并不足以完成对操作系统内核的加载。在mbr中我们只是简单的将loader程序加载到内存中运行。对于loader程序它执行的功能有通过BIOS提供的e820等功能（中断子功能，可以返回已安装的硬件信息）统计物理内存容量（32MB）、进入32位保护模式并开启分页机制，最后会对内核的elf文件进行解析加载跳转到内核的main函数中执行

**目前的电脑启动流程？**

计算机接电后，寄存器进行初始化，cpu从固定的复位入口开始执行，然后采用uefi代替了传统的Bios，他直接加载elf文件作为bootloader,那么bootloader内部主要是设置cpu为保护模式或长模式，初始化分页和堆栈，将操作系统内核加载并跳转到内核入口地址，后面就差不多

**他是怎样通过BIOS中断在loader阶段获得最大物理内存的？**

因为获取最大物理内存的时候还处于实模式下，他用过BIOS中断0x15的E820功能，他可以返回系统的每块内存起始地址长度类型等，首先准备一个可以接受这些信息的结构体，然后循环雕用这个中断，每次调用BIOS中断返回一条内存区域，并更新 continuation key 来获取下一条,对于可用内存类型，我们记录base+length的最大值，循环BIOS直到返回接是标志，这样就得到了最大可用物理内存

**bitmap长度是多少，什么时候进行初始化的？**

bitmap的长度是根据总物理内存动态计算出来的，在我的项目中，在loader阶段会通过BIOS中断得到总物理内存大小，再按照 4KB 为一页计算出总页数，bitmap 中每一位表示一页，因此 bitmap 的总长度就是总页数除以 8 得到的字节数。对于bitmap的初始化是在内核初始化阶段完成的，初始化时会先将所有位清零表示空闲内存，然后再把内核本身、页表等已经占用的物理页对应的位设置为 1，这样后续的内存分配器就可以在 bitmap 上正确分配剩余的物理页。

**内存管理？下面回答了。500和700大小的块，如何回归到内存中去分配**

在我的项目中，讲整页内存划分为7中不同大小的块，分别是16,32,64,128,156,512,1024字节，对于500和700大小因为他们都小于1024KB，那么都使用arena分配方式，每个arena大小为1页，减去arena头部，剩下的空间按照不同块得大小进行分割以链表的方式存储入free_list中，内存分配是向上取整到最近的块大小，当请求 500 字节时，因为小于 512 字节，会从 512 字节规格的 free list 中分配；请求 700 字节时，因为大于 512 字节但小于 1024 字节，会从 1024 字节规格的 free list 中分配。如果对应的 free list 没有空闲块，就会新开一个 arena。

**为什么要用先进先出的进程调度？？**

优先级调度，最短作业优先，抢占式优先

我在项目中用到先进先出的进程调度，目的是实现可运行的多进程调度，先进先出算法实现起来比较简单，每个进程按照进入队列的先后顺序执行，这样能快速验证进程切换，上下文保存和恢复，PCB管理等核心基址的正确性。并在此基础上面运行了时间便轮询的方法。

**那么还有哪些进程调度方法？**

**怎么基于时间片的 说了是硬件实现的 问软件定时器怎么实现（时间轮/最小堆）**

在我的项目中，时间片轮询调度是基于硬件时钟中断实现的。我用PIT硬件定时器生成时钟中断，设置固定频率触发时钟中断，每次中断调用中断处理函数，在中断处理函数中保存当前进程的上下文，然后当前进程需要被放回队列尾部，下一个就绪进程从队列头部取出运行。对于软件定时器的实现，他也是需要以来硬件时钟中断，在内核维护了一个超时队列或者计时器，每次中断检查定时器是否到期，要是到期就执行对应回调函数或唤醒线程，从而在软件层面实现定时操作

拓展：什么是时间论？

时间轮是一种高效管理大量定时器的软件结构，它将时间划分为固定大小的槽，每个槽对应一个时间片，定时器按到期时间放入对应槽中。系统通过硬件时钟中断触发 tick，每次 tick 当前指针向前移动一格，检查当前槽内的定时器是否到期，触发回调或重新计算放回轮盘，实现近似 O(1) 的定时器管理，常用于操作系统内核、网络协议栈和高性能定时任务框架。

 **你说你是参考ext2来写的文件系统，说下ext2/3/4都有什么区别？**

ext2是Linux上比较早期的文件系统，他的特点是结构简单，开销小，所以性能相对较好，也更容易实现。在日志功能上，ext2没有日志功能，属于非日志文件，要是ext3在ext4的在基础上引入了日志，提升了系统崩溃或断电后的数据恢复能力；在文件索引部分，ext2支持简单的多级索引，ext4在ext3索引目录基于基数树和类B+树。

基数树是一种多叉搜索树，树的叶子节点是实际的数据条树，每个节点有固定的，2的n次方指针指向子结点

那你为什么要用ext2?

原因他的设计比较简单，没有日志复制这样的复杂机制，对于我的小型os比较时用，他让我可以充分了解基础文件系统的设计思路，超级块+inode+数据块，通过位图管理，目录索引

ai:

ext2 是一个比较早期的 Linux 文件系统，特点是结构简单、性能开销小，但没有日志，系统崩溃时可能会丢数据。ext3 在 ext2 基础上增加了日志功能，提高了可靠性，而 ext4 则在此基础上进一步扩展，支持更大的文件系统，引入 extents 区间映射、延迟分配，以及基于 HTree 的目录索引，大幅提升了性能和可扩展性。
 在我的项目里，我选择实现 ext2，因为它的设计比较简单，没有日志和事务机制，更适合在小型 OS 上实现。通过 ext2 我能清楚地理解文件系统的基本构成，比如超级块、inode、数据块和位图管理，以及目录索引。这让我能从最核心的机制出发，逐步掌握文件系统的工作原理。

***

面试官可能会问到的问题：(自己猜的-----)

**开机启动的整个过程？**

**讲讲你的BootLoader？**

我的BootLoader实现分为MBR和Loader两个阶段，第一个阶段是MBR引导扇区，大小只有512字节，BIOS会将MBR加载到0x700初，并跳转到ox700处运行MBR，他主要负责初始化环境以及通过BIOS中断将Loader加载到内存并跳转到该Loader内存，在Loader代码中，首先通过BIOS中断获取最大物理内存为后面分配内核池和用户池大小使用，然后就是进行从实模式到保护模式的跳转，之后将kernel.bin以LBA方式从磁盘读到内存，之后找到内核入口点并跳转过去



**在loader中，他是怎样将kernel.bin从磁盘加载到内存的？**

他是通过硬盘的LBA模式来完成的，loader首先会向IDE控制器的I/O端口写入要读取的起始LBA地址和扇区数，然后向命令端口写入读命令0x20,接着不断轮询状态寄存器等待硬盘准备好数据，当DRQ位置1时，就用insw指令从数据端口0x1F0连续把一个扇区的数据读出来，loader一直循环这个过程，把kernei.bin全部搬运到提前约定好的物理内存地址(自己看是哪里？？)，然后跳转到这个起始物理地址进行执行

**怎样实现从实模式到保护模式的？**

首先开启A20地址线，避免访问1MB时产生地址回绕，然后构建好全局描述符表GDT,并使用lgdt指令将他的地址和界限加载到GDTR,这样在进入保护模式之后cpu就可以找到GDT去查询段描述符，接着把CR0寄存器的PE位置1,告诉cpu要进入保护模式，最后执行一条远调转，刷新流水线，这样CS段寄存器会加载新的段选择子，这样就完成了从实模式到保护模式的转变

**什么是段选择子？**

在实模式下，CS是段基址，CS*16+ip作为物理地址；但是现在进入保护模式CS是段选择子，段选择子他是一个16位的值，包含：索引：指向GDT/LDT中的某个段描述符；TI位：选择用GDT/LDT；RPL：特权级，cpu会根据这个段选择子在GDT里查段描述符，段描述符里又真正的基址，属性等信息。

那么这有个细节，就是要是这个段选择子是Ti位置1,那是cpu直接在LDT中找吗，LDT又通过lldt来告诉cpu他的位置吗，事实上cpu并不知道LDT在哪，他会先用LDTR寄存器找到GDT中的LDT描述符对应的索引，然后在GDT里找到这个索引对应的LDT描述符，这个描述符里面包含了LDT表的基址，那么CPU可以通过基址找到LDT表，然后再LDT表里根据段选择子的索引查对应的段描述符，最后才得到段基址+偏移，完成地址转换

那么更深面试官可能问你，为什么不把LDT像GDT那样直接暴露给CPU呢？

原因主要是GDT是全局表，而LDT使每个任务私有的，不同任务有不同的LDT，在进行任务接换是，会更新LDTR那么就实现了LDT的切换也就实现了多任务

LDTR寄存器保存了LDT描述符在GDT中的索引

**讲讲实模式和保护模式**

cpu上电后默认是实模式，地址空间只有1mb,兼容8086,cpu不做保护，也没有分页机制，时和BIOS调用和引导加载器使用；而保护模式是80286以后引入的，支持内存保护，分页，32位平坦寻址和多任务，通过GDT/LDT管理段和权限等级

**什么是平坦模式**

平坦模式是在保护模式下把段基址都设为0,段偏移覆盖0-4GB地址空间，这样cpu访问内存时直接用线性地址就行，不需要考虑段寄存器偏移，在我的项目中，在刚进入保护模式后，把CS/DS/SS都指向平坦段，这样内核直接可以用高半区地址访问内存，操作简单统一

**在开启保护模式之后，你是怎样实现分页机制的？**

在保护模式下他是32位的，我实现了二级分页结构，页目录表有1024项，每个页目录项指向一个页表，一个页表又有1024个页表项，每个页表项映射4kb的物理内存，那么正好覆盖了1024*1024 * 4kb=4GB物理空间；在打开分页机制前必须要做恒等映射，（也就是在页表里建设一段线性地址和物理地址一模一样的映射，保证cpu当前运行的代码设数据可以被正常访问。通过页目录的物理地址页入到CR3寄存器，然后将Cr0的PG位置1,分页功能就被打开了，分页启用后，CPU 的地址转换流程是：首先会将段机制转换成线性地址，然后将线性地址分成3部分，页目录索引（10位）->1024，页表索引（10位）->1024 ，页内偏移（12位）->4kb=2的12，cpu先用页目录索引在CR3中找到页目录项，在页目录像中取出页表机制加上页表索引可以找到页表，在根据找到的页表加上页内偏移可以找到最终的物理地址

**在进入初始化内核时，他重新设置了GDT/LDT，这和loader阶段设置的GDT有什么不同吗？**

在loader阶段，他只包含了基本的代码段数据段等，为了能让cpu能有实模式过渡到保护模式，在进入内核阶段，是为了完整的内核运行做准备的，那么GDT更完整，包含了内核代码段数据段，和用户态代码段和数据段，然后还设置了TSS，为多任务，用户态和内核态提供段描述符和权限控制

**TSS是什么，他主要包含什么结构**

每个任务都有TSS，他主要包含cpu寄存器快照，内核栈指针（用于用户态切换到内核态时使用），LDT段选择子，I/O位图

**在内核初始化阶段，你是怎样实现内存管理的**

在我的项目中，我的内存管理主要分无物理内存管理和虚拟内存管理两部分。在物理内存管理阶段，首先是在loader阶段通过BIOS中断获得总物理内存，然后从从总物理内存中减去低1MB的保留区和内核占用区得到可用物理内存，然后将可用物理内存分为内核池和用户池，分别用来管理内核和用户的内存，并且使用位图来管理每一页是否空闲，方便快速的分配和回收页；对于虚拟内存管理，首先构造页目录和页表，实现高半区映射和子映射，然后下块内存分配接口kmalloc和页级分配接口malloc_page,然后就是在释放虚拟内存时刷新TLB，保证页表更新生效

**讲一下malloc_page分配虚拟内存的整个步骤？**

分配虚拟页，分配物理页，建立虚拟页和物理页之间的映射，返回虚拟地址

那kmalloc呢？（扩展伙伴系统）

使用arena分配策略，避免内存浪费。在我的代码中，。。。

**讲一下TLB**

TLB快表是cpu内部用户缓存虚拟页到物理页映射的高速缓存，在cpu访问内存时，要是虚拟内存在TLB中命中，就无需查页表直接可以得到物理地址，提高了访问速度，但是在释放虚拟内存是，两者之间的建立的映射就失效了，需要刷新TLB重新建立映射，保证cpu使用的是最新的映射关系

**你在项目中是怎样实现中断的？**

在我的项目中，中断子系统的实现主要包含了三部分，初始化IDT，配置PIC以及注册中断处理函数。首先，我构建了IDT中断描述符表，每个中断向量都对应一个们描述符，这个门描述符包含中断处理函数的偏移，段选择子以及DPL(特权及），0-ox7F的硬件中断和cpu异常的DPL设置成0,然后0x80的DPL设置成3,给用户态触发，然后，我初始化了PIC，主片中断偏移映射到了0x20,从片偏移映射到0x28,开启IRQ(...分别控制什么)，保证时钟，键盘等硬件中断可以被cpu接收。最后，注册中断注册机制，这样当某个中断发生，cpu会根据idt找到响应的中断处理函数，执行中断处理函数并返回

要是给你的os加上网络模块你会怎么半？
