蚂蚁二面别怕别怕；为蚂蚁二面做准备，当然需要好好看一下mysql

概念：

数据库是用来持久化和管理数据的系统，核心目标是高效、可靠、一致地存取数据。传统单机数据库（如 MySQL）在数据量或并发量较小时性能很好，但随着规模扩大，会出现瓶颈。

分布式系统则是把数据和计算分散到多台机器上协同工作，以实现高可用、高并发和可扩展性。分布式数据库是在这种思想下的产物，它通过分片（Sharding）、**副本复制（Replication）和一致性协议（如 Raft、Paxos）**等机制来保证在多节点间仍然能保持数据一致和系统可靠。

binlog redolog undolog

**数据库崩溃后重新怎样进行恢复**

主要是通过redolog和undolog将数据恢复到“所有已提交事务生效，未提交事务完全撤销”，确保acid的原子性，一致性和持久性。

**redo log**:记录的是数据修改后的数据，主要是物理日志，比如说是把x页y位置的值修改成6这样，修改完后会写入到redo log这条消息，redo log是在磁盘，那么要是数据库崩溃了，那么在进行回复的时候，他会扫描redo log,每个事务都有一个状态，看这个事务是否被commit,只有被commit的事务才会被执行，没有commit的就需要通过undo log来进行回滚

**undo log**:记录的是数据修改前的数据，比如说上面把x页y位置的值修改成7,那么他会先将这个操作之间的就只先保存在undo log中，要是执行失败了还可以进行回退，他是需要刷新到磁盘的，但是他不是直接刷新到磁盘，因为修改很多，那么写入磁盘太麻烦了

undo log本身记录的就值将会先暂存到undo缓存区，不会直接刷到磁盘里面，当需要持久化undo log的时候，数据库会生成一条“记录undo log写入操作"的redo log

**细节，看看就行：**

那要是在undo缓存区还没进行刷盘操作数据库旧宕机了怎么半，此时redo log里面还没有生成一条undo log的执行，那么怎样恢复undo log

首先出现这种情况如下：就是数据库在处理事务的时候，会先在内存生成undo log,但是这个时候不会立马生产唵他的redo log,而是在事务执行到需要持久化到redo log的时候，比如说事务即将提交，才会生成redo log，那么就说明他此时还在缓存区呆着就说明这个事务尚未提交，那么就不需要恢复这个undo log,因为它对应的事务本来就没有提交

在说细节：还不是为了蚂蚁二面服了

**那要是这种情况内，就是我提交了很多的事务，但是此时都是放在buffer pool里面没有进行刷盘操作，那么此时你redo log里面已经因为循环写覆盖一部分了，这种该怎么解决**

通过checkpoint机制来保证：被覆盖的redo log队赢得藏也一定进行了刷盘操作。具体操作如下：

数据库会通过checkpoint动态标记以刷盘的藏也队赢得最后一条redo log,确保循环的时候只覆盖检查点之前的日志，检查点之后的日志会被保留，不会被覆盖

**可串行化：**

主要是通过2PL来保证的：加锁阶段申请锁，接锁阶段释放锁“

加锁阶段：事务执行时按照需求申请读锁写锁，读锁和写锁时互斥的，确保读写操作串行化

接锁：事务在执行完结束前不会释放锁，避免其他事务读取中间状态

mysql分布式有哪些锁：

**什么情况下可以不使用undolog保证原子性**

**不通过 “记录旧值回滚”，而是通过 “避免修改原数据” 或 “多版本隔离” 来保证 “要么全成、要么全败”**。

原子性本质是要么全成，要么全败“undo log主要是记录旧值回滚，要是系统能通过其他机制达到这个目的，就不需要undo log

1:lsm-tree

可以通过lsm-tree的wal机制保证，就像rocksdb一样，就是你在执行这个操作事务提交时把这个执行操作先刷盘放在wal里面，然后在将修改的数据放在memtable里面，要是此时发生了崩溃，wal没有的就是没有进行刷盘的，也就不用去恢复他了，保证了原子性

2：影子分页

主要就是你修改数据的时候写影子页，提交时原子切换指针，失败那么影子页左肺，元数据不变

比如现在数据库有一个数据页A，事务要把钱从100变200,那么他不会直接修改数据页A，而是先复制一个相同的数据页标记为A‘，然后对A’进行操作，当事务进行提交时，只需要原子性的把这个指针由A指向A‘，要是失败，那么页目录指针还是指向A，把A’直接丢弃就可以了

3：TIDBmvcc[她主要是通过记录多个提交的版本来实现原子性，但是我记得mvcc的版本也是用undo log串联起来的]

比如表中原由一条记录id=1,name="",版本号为10,那么此时要是有一个事务将id=1的name修改了，这个版本号时20，但是此时还没有进行提交，那么要是其他事务查询的时候，通过read view判断版本号20未提交，不可见，因此读到的版本号为10,要是已经提交了在读的时候就可以读到这个版本号为20的了，要是他的操作失败，就以就读到的是版本号10的，实现了原子性



**一个进程两个线程和两个进程访问一个物理地址？**

区别：

一个进程的两个线程也是共享虚拟地址的，所以直接就是共享物理地址，但是两个进程他的虚拟地址不一样，需要通过页表映射的方式映射到相同的物理地址

**raft和主从复制的区别**

侧重功能不同：

raft他是分布式共识算法，主要侧重强一致性和容错性

主从复制：就是将主节点的数据复制到从节点，侧重数据的备份，他允许从节点数据滞后

就以mysql举例，他就是主从复制型的，主节点写入就直接提交，之后通过异步或者半同步复制到从节点，那么这样要是主节点宕机，需要手动接换从节点到主节点，但是此时从可能存在数据丢失

要是是raft,那么所有写入都需要经过超过一半的从节点确认，要是主节点宕机了，新选举的主节点也能恢复完整数据，不会存在数据丢失的情况

因为他要是没有主节点在选举的时候就直接选举一个从节点，那可能出现网络分区的情况

但是raft不会，因为他需要成为经训者之后需要收到超过一半的投票才可以，那么分区少的哪个就选举不出来leader

所以我觉得主从复制适合读多写少的，对一致性要求不高的，

但是raft需要对数据一致性和可靠性要求极高，像金融系统，分布式锁，分布式数据库应该就用他



















