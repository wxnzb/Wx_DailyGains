

**～～～～innodb架构：**

innodb是mysql的一种存储引擎，负责数据存储，索引管理和事务处理，他支持acid事务，行级锁，外健，聚簇索引，有崩溃恢复能力。

innodb架构主要包括内存池，后台线程和磁盘文件组成

内存池中主要分为三部分：

buffer pool缓冲区：缓存最近的数据，当客户端来查询数据时，会先在buffer pool中找，找不到就去磁盘中

change pool缓冲区：当客户端有改变数据的操作，他会将这个操作先放入change pol,然后进行统一刷盘

log buffer:用来暂时存储redo log的数据，然后进行统一刷盘存入redo log

磁盘结构主要分为三部分：

系统表空间，用户表空间，redo log文件【重做日志文件】和归档文件

重做日志文件的作用：...

**～～～～Mysql一条语句执行经历哪些流程？**

大致会经过连接层->解析层->优化层->执行层四个阶段。首先，客户端和服务器建立连接，语句会经过权限验证，接着解析器进行语法和语义分析，把SQL转换成语法树；然后优化器会决定具体的执行计划，比如选择哪个索引，走全表扫描还是范围扫描；最后交给执行器，按执行计划调用存储引擎去真正读写数据。

**～～～～mysql索引是什么？**

索引是数据库的一种数据结构，主要作用是为了提高查找效率，就像是书的目录一样，但是他也有缺点，在时间方面：创建和删除索引都需要花费时间，空间方面，每个索引都需要占用物理内存

**～～～～mysql的索引有哪些**

从存储结构，有B+Tree索引，hash索引，全文索引和R-Tree索引

从应用层来看，有普通索引，唯一索引和组合索引

从数据物理存储顺序来看，有聚簇索引和非聚簇索引

**～～～～mysql索引存在哪里**

MySQL 的索引和数据都存放在 **InnoDB 表空间** 的 B+ 树页中，页默认大小 16KB，存储在磁盘上。查询时，InnoDB 会把需要的索引页加载到 **Buffer Pool** 中，后续访问直接在内存完成，从而减少磁盘 I/O。

**～～～～MYSQL为什么 InnoDB 用 B+ 树不用 B 树**

innodeDB用B+树而不是B树，主要是为了减少磁盘io并提高查询范围，首先，B+树的所有数据都存放在叶子节点，非叶子节点存储索引，这样一个磁盘页能容纳更多的索引建，树的高度更低，访问时磁盘io次数更少，然后就是B+树的叶子节点通过链表顺序连接，适合做范围查询和排序，扫描时主要顺着链表就好，而B树数据分散在各个节点上，范围查询效率差。最后innoDB数据页正好是磁盘页大小，B+树能充分利用磁盘欲读的局部性原理，批量加在数据，进一步提高性能

**～～～～B+树有什么优点？**

首先他是多路平衡树，单个节点能存放大量关键字，高度比二叉树更低，磁盘I/O减少；所有数据都存放在叶子节点，叶子节点之间通过链表连接方便了范围查询方便了顺序遍历，同时内部节点只存在key不存数据，在形同内存下可以容纳更多索引

**～～～～mysql有哪些锁**

行锁，表锁，间隙锁【锁定索引区间，不锁实际数据】，next-ket锁【行锁+间隙锁

细节：当主库有事务要提交的时候，会将这条以二进制形式记录到binlog文件，主库的dump线程循环检查binlog,当发现新的binlog,把他发送给从库，从库的i/o线程连接主库，把binlog的内容复制到relay log，然后从库的sql线程读取relay，顺序执行日志里的语句，把数据更新到从库

**～～～～慢查询【mysql有个慢查询日志，默热阈值是long_query_time=10s，也就是查询超过这个时间就会将这个请求记入慢查询日志】怎么优化？**

首先要优化就要知道慢查询这个问题出现到了哪里，我门找到了问题才能找到相应的解决方法：

1：没有索引导致的全表扫描---------建立合适的索引

SELECT name FROM user WHERE age = 25;

变为

ALTER TABLE user ADD INDEX idx_age(age);
SELECT name FROM user WHERE age = 25;

2：查询返回的数据量太大了；------避免 `SELECT *`，限制字段和分页

SELECT * FROM orders;

变为

SELECT id, user_id, amount FROM orders LIMIT 50;--只查需要的字段，并分页取数据。

3：排序，分组用到临时表或者文件排序；------建立联合索引避免临时表

SELECT * FROM orders ORDER BY user_id, create_time;--如果没有 `(user_id, create_time)` 的联合索引，会用临时表排序。

变为

ALTER TABLE orders ADD INDEX idx_user_time(user_id, create_time);--利用联合索引，避免临时表。
SELECT * FROM orders ORDER BY user_id, create_time;

4：sql写的不合理，用了or,函数包裹索引列-----改写语句避免函数和or

SELECT * FROM user WHERE age = 25 OR age = 30;

变为

SELECT * FROM user WHERE age = 25
UNION ALL
SELECT * FROM user WHERE age = 30;

**～～～～Mysql的事务特性：**

ACID

a【atomicity】原子性：事务的操作要么全部成功，要么全部失败【靠undo log】

c【consistency】一致性：事务前后数据库状态要保持一致，不那哪个出现多钱或者少钱的状况

i【isolation】隔离性：多个事务并发不会互相干扰，默认时可重复读【靠mvcc和锁机制】

d【durability】持久性：事务提交后对数据的修改永久保存，系统宕机也可以通过redo log恢复

你知道mysql的主从复制主要用的什么吗？为什么mysql的主从复制没有用raft

它主要用的是binlog日志入值，主库把binlog传给从库，从库顺序重放

细节：它主要用的是binlog日志复制，主库写入binlog，dump线程传给从库，从库i/o线程写入relay log,sql线程回放

不用raft的原因：raft强调的是强一致性，比较适合分布式数据库，向etcd呀

mysql主从复制更看重性能，它主要实现读扩展 + 备份 + 高性能。用异步或者半同步的方术，不要求主节点和强节点强一致，要求更高的性能







**～～～～mysql的mvcc(多版本并发控制)**

mysql的事务的个理性：读未提交，读已提交，可重复读，串行话

innodb默认可重复读，可重复读指一个事务执行过程中看到的数据，一直根这个事务启动时看到的数据时一样的。

mysql为了保证事务从启动到结束整个生命周期看到的数据是一样的，他有两个办法：首先就是在读加共享锁，在写加排他锁，但是加上派他所之后，其他事务就不能进行读取。有了问题，就有了解决问题的办法，---mvcc(解决不可重复读，幻读)

快照读和当前读，快照读就是普通读，他就是利用mvcc机制读取快照中的数据，不需要加锁；(那么有个疑问，他是读取那个版本的快照呢？还是最后一个？)

当前读，他读取的是最新记录的版本，会进行加锁，特殊读，和对数据的增删改都使用当前读

事务日志undo log:保存了数据的各个历史版本，用于事务回滚，保证事务一致性

innodb里面每个事务有唯一的事务id,叫做transaction id,每个新的事务开始之前都要进行申请，申请的顺序严格递增

版本列：就是一个事务他在进行了很多次修改后，那么他现在的roll_pointer就是头指针，后面将每次修改事务时保存的开找undo_log通过链表的形式串联起来，这样想找到这个事务id的任何一个快照都可以轻松找到，这就时版本链

一致性视图：现在undo_log里面已经保存了各个版本的快照，那么使用哪个版本的呢？这就用到了readvi

innodb存储需要支持一条数据可以保留多个历史版本，他的聚簇索引有两个隐藏列：

trx_id:当一个事务对一个聚簇索引进行改动时，就会把该事务的事务id记录在trx_id隐藏列里面.

roll_pointer：当一个事务对一个聚簇索引进行改动，会把该洞之前的记录到undo log中，然后这个指针指向旧版本记录

mvcc的整个操作流程：

readview是事务在时用mvcc机制进行快照读操作时产生的一致性视图，readview有如下关键信息：

trx_ids就是在创建readview时，当前数据库中活跃事务【启动了但是还没有提交的事务】的id列表

min_trx_id就是在创建readview时，当前活跃时或中id最小的一个

max_trx_id:这个需要强调一下，并不是只最大的活跃事务的id而是下一个事务id,也就是最大活跃事务id+1

creator_trx_id:指得是这个readview事务的id,时有在对表中数据进行修改是才会有，否则默认为0

我现在说一下readview读取数据的整个流程：首先事务要读取一个数据，那么他就会找到这个数据在聚簇索引页的最新版本，最新版本里面带有trx_id和roll_pointer,roll_pointer 指向该行记录的上一个旧版本undo log，版本里有trx_id和roll_pointor,通过指针将这些版本串起来了，先将最新版本的trx_id和readview里面的成员进行比较，要是小于min_trx_id,那么说明一将提交直接读取就可以，要是>max_trx_id,那么就时未来的事务，不可读，继续遍历，要是在min_tex_id和max_trx之间，那么看是否在trx_ids中，要是不存在【为什么会存在不存在的情况：事务执行有的快有的慢，在生成读快照的时候先启动的时候还没结束，后启动的事务已经结束了，该事务id不在活跃事务集合中】，就说明以提交，那么也可以读取，要是存在，那么说明此是这个事务正处于正在写但是未提交的状态，那么也不可以读，继续向下找，直到可以读取了就可以了



**～～～～acid的一致性和cap的一致性一样吗**

acid的一致性：事务执行前后，数据库必须保持一致的状态

cap的一致性：系统在所有节点上看到的数据时一致的





























