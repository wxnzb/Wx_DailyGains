Innodb引擎使用的什么数据结构作为索引，为什么选这个数据结构

我去，这个原来问的是b+树呀

**～～～～innodb架构：**

innodb是mysql默认的存储引擎，他采用行级锁+mvcc来支持事务，通过bufer pool.redo log,undo log,后台线程等来实现数据管理

我觉得可一把他具体分为：后台线程系统；磁盘存储；buffer pool;日志系统来讲

内存结构：

buffer pool:innodb数据页缓存，使用lru+free list+flush list管理；

log buffer:缓存redo log,周期性进行刷盘

磁盘结构：

表空间：主要是.ibd文件，包含数据页，索引页

数据页大小：16kb

redo log:记录物理更改，主要用于崩溃恢复

undo log:主要是存储事务的回滚信息

日志系统：

主要就是redo undo log

redo log【重做日志】：记录对数据页的物理修改，支持崩溃恢复

undo log【回归日志】：记录修改前的数据，支持事务回滚

后台线程系统：

master thread:负责脏页刷新

io thread:读写磁盘页

purge thread:清理已经提交事务的undo log

page cleaner thread:异步刷脏页

## ✅ InnoDB 写操作的完整流程（精简口述版）

> 当一个事务执行写操作（如 `UPDATE`、`INSERT`、`DELETE`）时，InnoDB 的整个流程如下：

1️⃣ **加载数据页到 Buffer Pool**

- InnoDB 会先判断要修改的数据页是否在 Buffer Pool 中。
- 如果不在，就从磁盘读入内存（Buffer Pool）。

2️⃣ **生成 Undo Log（回滚日志）**

- 修改前，会把旧数据写入 Undo Log，用于事务回滚和 MVCC 多版本控制。
- Undo Log 记录的是“旧版本”，存在 Undo Segment 中。

3️⃣ **修改 Buffer Pool 中的数据页（内存写）**

- 在内存中直接修改数据页，不立刻写磁盘。
- 这个修改后的页会被标记为 “脏页（dirty page）”。

4️⃣ **记录 Redo Log（重做日志）到 Log Buffer**

- 同时生成 redo log，记录“这次修改了哪个页、改了什么”。
- redo log 先写入 **Log Buffer**。

5️⃣ **事务提交时：刷 Redo Log**

- 事务提交时，InnoDB 会将 **Log Buffer 刷入磁盘 redo log 文件**（`ib_logfile`），确保崩溃恢复能力。
- 此时事务才算真正“持久化”。

6️⃣ **后台线程异步刷脏页（flush）**

- 后台线程会定期把脏页从 Buffer Pool 刷回磁盘（写回表空间文件 `.ibd`）。
- 这一步是异步的，不影响事务提交速度。

**～～～～✅Mysql一条语句执行经历哪些流程？**

大致会经过连接层->解析层->优化层->执行层四个阶段。首先，客户端和服务器建立连接，语句会经过权限验证，接着解析器进行语法和语义分析，把SQL转换成语法树；然后优化器会决定具体的执行计划，比如选择哪个索引，走全表扫描还是范围扫描；最后交给执行器，按执行计划调用存储引擎去真正读写数据。

具体讲一下优化层【被小红书问到了】

优化层他存在的目的就是在多个执行方案中选择执行代价最下的执行计划，就比如一句SQL,MYSQL可以有很多查询方式，优化器可以帮你选择最快的那一种。

他有两种优化方式：逻辑优化和物理优化

逻辑优化【通过改写SQL语句来实现高效率执行】：

1：子查询改写成JOIN

2：谓词下推：提前把过滤条件推导存储引擎层，减少返回数量

eg:SELECT * FROM user WHERE age > 30;

优化器会让>30的尽可能在索引扫描阶段就过滤掉

3：长量折叠：把能体减算出来的表达式直接算出来

4：消除冗余排序：若索引已经满足order by,cgroup by,就跳过排序操作

物理优化：在多种执行过程中挑选一个成本最低的

通过比较不同执行消耗的io代价，cpu代价和网络代价来选择

为什么是 (name, gender, age) 这个顺序？

字段顺序上我会把**区分度高的字段放前面**（例如 name），像 gender 这种区分度低的字段适合放在后面。



**～～～～mysql索引是什么？**

索引是数据库的一种数据结构，主要作用是为了提高查找效率，就像是书的目录一样，但是他也有缺点，在时间方面：创建和删除索引都需要花费时间，空间方面，每个索引都需要占用物理内存

ai:MySQL 索引其实就是一种有序的数据结构，用来加速数据查询。
 在 InnoDB 里底层是 B+ 树，它能通过树形结构快速定位数据位置，避免全表扫描。
 主键索引的叶子节点直接存储整行数据，是聚簇索引；
 而普通索引的叶子节点存储主键值，通过主键回表拿到完整数据。
 索引能显著提升查询性能，但也会增加写入和维护开销，所以要合理设计。

扩展：是不是越多越好？

不是的，索引也占有一定的内存空间

为什么索引能够加快查找？

**～～～～mysql的索引有哪些**

从存储结构，有B+Tree索引，hash索引，全文索引和R-Tree索引【空间索引】

从应用层来看，有普通索引，唯一索引和主键索引和联合索引

从数据存储方式来看，有聚簇索引和非聚簇索引

**～～～～mysql索引存在哪里**

MySQL 的索引和数据都存放在 **InnoDB 表空间** 的 B+ 树页中，页默认大小 16KB，存储在磁盘上。查询时，InnoDB 会把需要的索引页加载到 **Buffer Pool** 中，后续访问直接在内存完成，从而减少磁盘 I/O。

**～～～～MYSQL为什么 InnoDB 用 B+ 树不用 B 树**，我去，原来b-树就是B树呀

innodeDB用B+树而不是B树，主要是为了减少磁盘io并提高查询范围，首先，B+树的所有数据都存放在叶子节点，非叶子节点存储索引，这样一个磁盘页能容纳更多的索引建，树的高度更低，访问时磁盘io次数更少，然后就是B+树的叶子节点通过链表顺序连接，适合做范围查询和排序，扫描时主要顺着链表就好，而B树数据分散在各个节点上，范围查询效率差。最后innoDB数据页正好是磁盘页大小，B+树能充分利用磁盘欲读的局部性原理，批量加在数据，进一步提高性能

**～～～～B+树有什么优点？**

首先他是多路平衡树，单个节点能存放大量关键字，高度比二叉树更低，磁盘I/O减少；所有数据都存放在叶子节点，叶子节点之间通过链表连接方便了范围查询方便了顺序遍历，同时内部节点只存在key不存数据，在形同内存下可以容纳更多索引

**～～～～mysql有哪些锁**

表锁，行锁可以分为间隙锁【锁定索引区间，不锁实际数据】和记录锁【锁住行的具体数据】和next-ket锁【记录锁+间隙锁】

下面这个属于索引失效吗

**MySQL为什么查询速度慢？**和下面是一个问题呢

**～～～～慢查询【mysql有个慢查询日志，默热阈值是long_query_time=10s，也就是查询超过这个时间就会将这个请求记入慢查询日志】怎么优化？**

首先要优化就要知道慢查询这个问题出现到了哪里，我门找到了问题才能找到相应的解决方法：

**1：没有索引导致的全表扫描---------建立合适的索引**

SELECT name FROM user WHERE age = 25;

变为

ALTER TABLE user ADD INDEX idx_age(age);
SELECT name FROM user WHERE age = 25;

**2：查询返回的数据量太大了；------避免 `SELECT *`，限制字段和分页**

SELECT * FROM orders;

变为

SELECT id, user_id, amount FROM orders LIMIT 50;--只查需要的字段，并分页取数据。

**3：排序，分组用到临时表或者文件排序；------建立联合索引避免临时表**

SELECT * FROM orders ORDER BY user_id, create_time;--如果没有 `(user_id, create_time)` 的联合索引，会用临时表排序。

变为

ALTER TABLE orders ADD INDEX idx_user_time(user_id, create_time);--利用联合索引，避免临时表。
SELECT * FROM orders ORDER BY user_id, create_time;

**4：sql写的不合理，用了or,函数包裹索引列-----改写语句避免函数和or**

SELECT * FROM user WHERE age = 25 OR age = 30;

变为

SELECT * FROM user WHERE age = 25
UNION ALL
SELECT * FROM user WHERE age = 30;

**三大范式**

数据库的范式主要是为了减少数据冗余，避免更新异常，提高数据一致性而提出的一系列设计规则。

第一范式：字段都是原子性的，不可再分

第二范式：在满足第一范式的情况下，每个非主键字段都完全依赖于主键。

第三范式：在满足第二范式的情况下，非主键字段不依赖于其他非主键字段

**～～～～Mysql的事务特性：**

ACID

a【atomicity】原子性：事务的操作要么全部成功，要么全部失败【靠undo log】

c【consistency】一致性：事务前后数据库状态要保持一致，不那哪个出现多钱或者少钱的状况

i【isolation】隔离性：多个事务并发不会互相干扰，默认时可重复读【靠mvcc和锁机制】

d【durability】持久性：事务提交后对数据的修改永久保存【靠redo log】

**mysql的主从复制主要用的什么吗？为什么mysql的主从复制没有用raft**

mysql主要通过**主库binlog**和**从库relay**来实现主从复制的

细节：主库执行完事务后会把数据记录到binlog中，此时从库会用自己的i/o线程主动连接主库并请求binlog,诸苦的dump线程会把binlog的内容发送给这个i/o线程，从库的i/o线程把收到的binlog入值写入到本地的relay log,然后SQL线程读取relay log并在从库执行相同的操作从而实现的数据一致

细节：当主库有事务要提交的时候，会将这条以二进制形式记录到binlog文件，主库的dump线程循环检查binlog,当发现新的binlog,把他发送给从库，从库的i/o线程连接主库，把binlog的内容复制到relay log，然后从库的sql线程读取relay，顺序执行日志里的语句，把数据更新到从库

**不用raft的原因**：raft强调的是强一致性，比较适合分布式数据库，向etcd呀

mysql主从复制更看重性能，而raft他是强一致性算法，那延迟性就肯定比较高，他更强调的是cp,而mysql更强调的是ap,而且在提出mysql主从一致的时候应该还没有raft.

**～～～～四种隔离机制：读未提交,读已提交，可重复读，串行化**

**读未提交**：一个事务他还没有提交时，其他事务就能看到他做的变更，但是他可能会产生脏读

就是a事务改变了个数据还没有提交，此时b事务读取了该数据，但是a有进行回滚了，那么b就产生了脏读

**读已提交**：一个事务提交时，其他事务才能看到他做的变更，但是他会产生不可重复读

事务a刚开始读取一个数据发现时100,但是接着事务b修改数据成了500并进行了提交，此时事务a再去读数据发现是500，和之前不一样了

**可重复读**：一个事务在执行过程中看到的数据和这个书事务启动时看到的数据时一样的【因为他加了记录锁】，mysql innodb默认隔离级别，但是他可能会产生幻读【解决方法：加上间隙锁】，也就是整体上加了next-key 锁

事务a刚开始执行>100的返回查询发现行数是10,然后接着事务b执行了操作并提交之后，a在执行>100的返回查询结果发现行数是11

其实刚开始我也感觉幻读和不可重复读很像，就是相同的操作，前后一个查的是数据变得不一样了，一个查的是行数变得不一样了

**那么innodb是怎样避免幻读的？**

他主要是通过间隙锁来避免幻读的

也就是事务a刚开始执行>100的返回查询发现行数是10，此时innodb会对间隙加锁，保证其他事务无法在这个范围插入新行，从而避免幻读

**串行化**：会对记录加上读写锁，当一个事务修改时要是发生了读写冲突，那么他会等待上一个事务执行完后他才执行

事务a在执行一条语句想要查询或者修改这条数据，然后b也向操作这条数据，那么b必须等待a操作完之后他才可以操作

**～～～～mysql的mvcc(多版本并发控制)**

mysql的事务的个理性：读未提交，读已提交，可重复读，串行话

innodb默认可重复读，可重复读指一个事务执行过程中看到的数据，一直根这个事务启动时看到的数据时一样的。

mysql为了保证事务从启动到结束整个生命周期看到的数据是一样的，他有两个办法：首先就是在读加共享锁，在写加排他锁，但是加上派他所之后，其他事务就不能进行读取。有了问题，就有了解决问题的办法，---mvcc(解决不可重复读，幻读)

快照读和当前读，快照读就是普通读，他就是利用mvcc机制读取快照中的数据，不需要加锁；(那么有个疑问，他是读取那个版本的快照呢？还是最后一个？)

当前读，他读取的是最新记录的版本，会进行加锁，特殊读，和对数据的增删改都使用当前读

事务日志undo log:保存了数据的各个历史版本，用于事务回滚，保证事务一致性

innodb里面每个事务有唯一的事务id,叫做transaction id,每个新的事务开始之前都要进行申请，申请的顺序严格递增

版本列：就是一个事务他在进行了很多次修改后，那么他现在的roll_pointer就是头指针，后面将每次修改事务时保存的开找undo_log通过链表的形式串联起来，这样想找到这个事务id的任何一个快照都可以轻松找到，这就时版本链

一致性视图：现在undo_log里面已经保存了各个版本的快照，那么使用哪个版本的呢？这就用到了readvi

innodb存储需要支持一条数据可以保留多个历史版本，他的聚簇索引有两个隐藏列：

trx_id:当一个事务对一个聚簇索引进行改动时，就会把该事务的事务id记录在trx_id隐藏列里面.

roll_pointer：当一个事务对一个聚簇索引进行改动，会把该洞之前的记录到undo log中，然后这个指针指向旧版本记录

mvcc的整个操作流程：

readview是事务在时用mvcc机制进行快照读操作时产生的一致性视图，readview有如下关键信息：

trx_ids就是在创建readview时，当前数据库中活跃事务【启动了但是还没有提交的事务】的id列表

min_trx_id就是在创建readview时，当前活跃时或中id最小的一个

max_trx_id:这个需要强调一下，并不是只最大的活跃事务的id而是下一个事务id,也就是最大活跃事务id+1

creator_trx_id:指得是这个readview事务的id,时有在对表中数据进行修改是才会有，否则默认为0

我现在说一下readview读取数据的整个流程：首先事务要读取一个数据，那么他就会找到这个数据在聚簇索引页的最新版本，最新版本里面带有trx_id和roll_pointer,roll_pointer 指向该行记录的上一个旧版本undo log，版本里有trx_id和roll_pointor,通过指针将这些版本串起来了，先将最新版本的trx_id和readview里面的成员进行比较，要是小于min_trx_id,那么说明一将提交直接读取就可以，要是>max_trx_id,那么就时未来的事务，不可读，继续遍历，要是在min_tex_id和max_trx之间，那么看是否在trx_ids中，要是不存在【为什么会存在不存在的情况：事务执行有的快有的慢，在生成读快照的时候先启动的时候还没结束，后启动的事务已经结束了，该事务id不在活跃事务集合中】，就说明以提交，那么也可以读取，要是存在，那么说明此是这个事务正处于正在写但是未提交的状态，那么也不可以读，继续向下找，直到可以读取了就可以了

**上面的内容适合看不适合将太长了，总结一下：**

**MVCC（多版本并发控制）** 是 InnoDB 实现高并发、无锁一致性读的机制。
 它通过 **undo log** 保存历史版本，通过 **ReadView** 确定当前事务能看到哪个版本的数据。
 每行记录都有 `trx_id`（最后修改它的事务 ID）和 `roll_pointer`（指向上一个版本），
 这样就形成了一条“版本链”。

当事务执行 `SELECT`（快照读）时，会生成一个 **ReadView**，用来判断哪些版本可见：

在 **读已提交（RC）** 下，每次查询都会重新生成 ReadView，因此可能读到其他事务新提交的数据 → 会产生“不可重复读”；

在 **可重复读（RR）** 下，只在第一次查询时生成 ReadView，并在整个事务中复用 → 事务期间读取结果保持一致，避免不可重复读。

判断可见性时，InnoDB 会从最新版本开始，沿着 undo log 版本链往回找，直到找到一个对当前 ReadView 可见的版本为止。

**读已提交和可重复读在mvcc上的区别是什么也就是建立readview上的时间区别**

读已提交每次执行SETLECT时都会重新生成一个新的read view,所以每次查询都能看到其他事务已经提交的新数据，

但是可重复读，他是在事务启动时生成一个read view,之后就复用那一个，因此这个read view在整个事务期间都不会改变，那么即使其他事务提交了新数据，本事务仍然看到的是旧i数据

**RR隔离级别下会出现幻读吗**

**如何避免幻读的，能避免全部幻读吗**
**mvcc是主要在读操作还是写操作**

**～～～～acid的一致性和cap的一致性一样吗**

acid的一致性：事务执行前后，数据库必须保持一致的状态

cap的一致性：系统在所有节点上看到的数据时一致的

**数据库主键索引和唯一索引有什么区别？**

主键索引要求列值必须唯一且不能是NULL，但是唯一索引只是要求列值必须唯一，但是可以有多个NULL的存在

数量上面，一个表只能有一个主键索引，但是一个表可以有多个唯一索引

在innodb中，主键索引会自动创建为聚簇索引，数据存储在叶子节点；但是唯一索引他是非聚簇索引，他的叶子节点存储的是指向数据行的值

而且主键索引一般可以被其他表作为外键使用，但是唯一索引一般不可以

**了解什么是SQL注入吗？该怎么防范？**

SQL诸如是一种网络安全漏洞，攻击者主要通过在应用程序的输入字段中插入恶意的SQL代码，从而操纵后台数据库执行非预期的SQL命令。使用参数化查询，将SQL语句和数据分开处理，确保用户输入只是被当作数据，而不是SQL代码的一部分；输入验证和过滤，对用户输入进行严格的验证，过滤掉特殊字符，限制输入长度以及格式。

**mysql 最左匹配原则**

我理解的mysql左左匹配原则时对于一个符合索引，他能利用的列必须从最左开始，就比如说对于符合索引(a,b,c),查询饥饿以使用的索引的列就得是从最左测开始的连续前缀列，不能跳过中间列；向where a=1或者where a=1 and b=2就可以，但是像where b=2或者where b=2 and c=3就不行

那么面时官要是问，那他底层时怎样的，为什么这样就不行

因为对于maysql来说他存储索引是在B+树中，因为他复合索引时(a,b,c)那么他在B+————树中的存储从上层到下层就是先a下来b下来c，你要时不知道a,就无法在 B+ 树第一层定位，无法直接利用索引，那么只能做全表扫描或者回表过滤【查】了

**binlog和redolog的区别**

binlog是归档日志，是mysql的server层生成的日志，主要是用于数据恢复，主从复制；

redo log叫做重做日志，是mysql的innodb存储引擎层生成的日志，主要作用是保证了事务的持久性,acid中的d

他们的写入时机不同，binlog是事务提交时一次性写入，记录整个事务的操作；而redo log是在事务执行过程中不多写入，提交时会保证持久化【wal】

而且binlog他是追加写，不会进行覆盖，因此会保存为多个文件；但是redo log他的大小是固定的，因此他是循环写，写满之后继续写恢覆盖之前的数据



倒排索引

**RocksDB了解么**

rocksdb是一个基于lsm-tree结构的高性能嵌入式kv数据库，有facebook从leveldb优化而来的

底层采用 **LSM-Tree** 结构，数据写入时先写 **WAL（预写日志）** 保证持久性，然后写入 **MemTable（内存跳表）**，
 当内存达到阈值后刷盘生成 **SSTable 文件**。后台通过 **Compaction** 合并 SST 文件，维持数据有序性与查询效率。

**mysql分布式锁如何实现？**

他一般是利用数据库的事务和唯一性约束来保证同一时间只有一个客户端能拿到锁，我目前知道的有两种方法，

第一种创建一个锁表，然后用主键或者唯一索引插入一条记录，谁插入谁就获取锁；

第二种对锁表里的一行做select got updata【也就是加记录锁】,这样只能有以和事务能操作成功

**怎样实现节点合并和拆分？**小红书问过

**节点拆分【在给节点插入数据时产生】**

当在一个节点中插入新键值时，发现此时节点存储数据满了，那么innodb会创建一个新页，把原页中的一般记录移动到新页，把中间那个“分解key”提升到父节点，更新父节点指针【这是什么意思】，要是父节点也满了，就会递归向上分裂，要时一致分裂到了根节点，此时就会生成一个新的根节点

因此我感觉插入可能会导致树的高度增高，还有就是插入成本可能不断递归，成本较高

**节点合并【在给节点删除数据时产生】**

当一个删除一个节点的记录时，要是节点的使用空间地域50%,那么innodb会将他和相邻兄弟节点进行合并，就是把当前页的记录总量和相邻节点的总录放在一个页中，然后删除父节点中对应的分解key,要是父节点也空了，可能递归向上合并

因此我感觉删除可能会导致树的高度降低，还有就是插入成本可能不断递归，成本较高

 mysql数据迁移怎么做

意向表？

MySQL三层B+树能存储多少数据

mysql和mongodb区别

关系型数据库为啥叫做这样

mysql每张表属于不同的存储引擎，但是这两个表有关联，那么怎样进行查询？

ai:

“MySQL 可以跨存储引擎查询，比如 InnoDB 和 MyISAM 表可以做 JOIN，但是要注意：事务无法跨存储引擎保证一致性，锁机制不同可能影响性能，外键约束无法生效。因此这种查询适合读操作，如果涉及写操作建议把所有表统一到 InnoDB。”

B+树和lms-tree是区别？

**如何查看sql执行效率**

我会通过sql提供的分析工具来定为问题，一般我通过explain select,explain可以看到SQL的执行计划，比如使用了那个索引，是否发生了全表扫描之类的；

要是我想看整体执行慢的SQL，我一般会开启slow_query_log,然后查看slow_log表，分析哪些SQL最耗时，从而优化SQL语句

**什么是索引下推**

存储引擎在索引扫描时提前过滤非必要的数据，减少回表

举例：假设现在有联合索引(name,age),我select * from user where name like 'A%' and age >20,要是没有索引下推，那就先根据name的条件在表中进行扫描，在server层判断age,要是name满足的很多，那么就会有大量无用回表。现在有了索引下推，就可以在索引遍历阶段就一起进行判断，只有同时满足名字和age才会回表，减少了回表的次数

还有一个跟他长的很像，是谓词下推？

就是把应该返回给sql层数据在存储引擎进行筛选而不是在SQL层进行筛选再返回给存储层

傻瓜【SQL层就是server层】

**索引下推是 MySQL InnoDB 的一种谓词下推优化。区别在于，索引下推针对索引扫描过程，减少回表；而谓词下推的概念更广，强调把过滤条件尽量下推到离数据更近的地方，比如存储引擎或分区层面**

INNER JOIN（内连接）：只返回两个表中匹配条件的行，即两表交集部分。
LEFT JOIN（左连接）：返回左表所有行，右表中匹配的行对应显示，不匹配则右表字段为 NULL。

innodb和myisam的区别：

innodb支持事务，他不支持

innodb支持外键；他不支持

innodb支持行锁表锁；他只支持表锁

inndb适合高并发写操作；他支持读多写少的情况

**什么是回表查询**

回表查询就是使用非聚簇索引查询时，数据库需要先通过索引来定位主键值，然后根据主键值去聚簇索引中取出完整数据行

要是他问应该怎么优化回表？

可以通过覆盖索引，就是查询的字段在索引中能找到就不需要回表

**什么是索引失效？**

使用索引的目的是加快查询数据，但是一些时候由于SQL语句写法，索引的设计问题，导致数据库优化器放弃使用索引，转而进行全表扫描，大幅度降低了查询效率。比如说使用不等号，优化器可能觉得要排出大量数据，就会选择全表扫描；模糊查询以%开头，比如说where name like '%张三'，由于前缀不确定，无法利用B+树索引有序性，只能进行全表扫描；要是将他改成 where name like '张三%'就可以正常使用索引；也可能是违反了联合索引的最左前缀原则；或者使用or连接非索引列，比如 where a=1 or b=2,要是a是索引但是b不是，那么优化器可能不会利用a的索引，去进行全局扫描















