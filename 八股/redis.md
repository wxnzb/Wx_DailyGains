## redis
- **1:Redis和Memcached有什么区别和联系**
- ----------------------------------
共同点：

都是基于内存的数据库，一般当作缓存使用

都有过期策略

性能都很高

区别：

Redis支持的数据类型更丰富，有string,hash,list,set,zset等，但是memcached只有最简单的k-v

Redis支持持久化功能，可以将内存数据存入磁盘，重启可以从磁盘加载进行使用

Redis支持集群模式，但是memcached不支持

Resdis支持订阅模型，Lua脚本，事务等功能，但是memcached不支持

- -------------------------------------
**2:为什么Redis作为MySQL的缓存?**

Redis具备高性能和高并发

高性能体现：要使用户第一次访问MySQL数据，因为他存在磁盘，读取比较费时间，之后他就被缓存在redis中，下次要是继续读取这些数据，就直接从内存中读取，速度提高

高并发体现：直接访问Redis能承受的请求元元大于MySQL

**3：Redis是单线程的吗？**

Redis单线程指的是：从接收客户端请求->解析请求->进行读写操作->发送数据给客户端这一整个过程是由一个线程完成的

Redis在启动的时候，会启动后台线程

在2.6版本之前，是启动两个后台线程，处理关闭文件，aof刷盘

在4.o版本之后，又加了一个新的后台线程，异步释放Redis内存

有三个后台线程，他们相当于消费者，然后对redis的操作相当于生产者，那么就会三个队列，生产者方，消费者取

**4：Redis他不是将数据存放在内存吗，怎样实现数据不丢失？**

Redis会将数据持久化到磁盘

**5：那么Redis实现持久化的方式有哪些?**

AOF:每次执行写操作，就会将这个命令追加到文件

RDP快照：将某一时刻的数据以二进制的方式写到磁盘

但是好像在Redis4.0版本之后，就继承了AOF和RDP的优点

**6:Redis使用的过期删除策略是什么？**

Redis对key设置过期时间并将他放在过期字典里面，他有两种删除策略

惰性删除：他不主动删除过期健，每次访问数据库里面的key时都要检测他是否过期，要是过期就删除，但是这样的话就时要是不访问某些已经过期的key他就一直占用内存

定期删除：每个一段时间就随机取出固定数量的key检测他们是否过期，要是过期的key占的比例超过一定值就继续这个操作

**7：LRU算法和LFU算法有什么区别？**

Least Recently Used:

他底层使用的是链表，当操作元素时，这个链表就会像前移，所以要是要进行淘汰，就淘汰后面的，他的缺点，使用链表会带来额外的空间，而且将链表向前移的操作太费时间了

因此Redis进行了优化，他在一个Redis对向结构体添加一个字段：数据的最后访问时间，要是进行淘汰，他会随机选取对向，然后淘汰最久没用的那个---但是他也有缺点，就是应用要是一次读取大量数据，但是这些数据只被读取一次，那么他们回流在Redis缓存中很长时间，造成缓存污染

那么就引入了LFU

Least Frequently Used

他记录的是访问次数，访问次数少的将会被淘汰

**8：集群脑裂是什么意思？**

在Redis主从架构中，主节点负责写，从节点负责读，主节点既连接客户端又连接从节点。当主节点与从节点出现网络问题但是和客户端没有，那么继续可以接收客户端数据进行写，但是从节点们都以为主节点挂了，就在从节点中重新选择了一个把他当作主节点，但是现在第一个主节点与从节点之间的网络问题好了，那么现在就有两个主节点，这就是脑裂现象

如何监测redis脑裂？

**9：集群脑裂导致数据丢失怎么办？**

现状：那么哨兵已经选出了新的主节点，原来那个就会成为从节点，从节点会像新的主节点请求数据同步，第一次时全复制，那么他之前写入的数据就丢了

解决：当主节点发现节点下线或者通信超时的总数量小于固定值，那么禁止主节点进行写数据，要是又一定数量的从节点和主节点锻炼或者从节点从主节点读的时候书监超时那么主节点就不能和客户端进行交互了

**10：Redis怎样实现服务高可用？**

主从复制，哨兵模式，切片集群

哨兵模式：监控主从服务器，并且提供主从节点故障转移的功能

切片集群模式：Redis缓存数量太大，一台机子已经承受不了了，就会将数据进行接片，分配到不同的服务器上面

**redis的aof持久化：**

客户端在发送写命令时，redis会执行写命令，并将命令记录到硬盘【读命令是不会被记录到硬盘的】，他的持久化方法的潜在风险：

第一个是在redis执行完数据之后，还没有将他写入到营盘中，redis就宕机了，那么就可能存在数据丢失的情况

第二个是他在执行完写操作之后才会将命令写入硬盘，他却是不会阻塞当前的写操作，但是可能会阻塞下一个命令的执行

为了解决第二个问题，redis在执行完写操作后，会将命令追加打破server.aof_buf缓冲区，然后通过write系统调用，将aof_buf缓冲区的数据写入到aof文件，此时数据并没有写入到硬盘，而是写入到了内核缓冲区，等待内核将数据写入硬盘，要想解决第一个问题，需要**AOF 持久化策略**（`appendfsync` 配置）来控制写入磁盘时机

为什么redis是先执行命令在将他存在硬盘里面？

第一防止命令语法本来就有问题，要是不进行命令语言检查就直接将他存到硬盘，redis在恢复数据的时候，可能会出错

第二个好处，不会阻塞当前写操作命令的执行

那么aof的写操作一致追加到aof文件里，那么文件的大小会越来越大，那么要是重启redis的时候，读取aof文件恢复数据那得多满鸭，因此就引入了aof重写机制，他就是当aof文件的大小到达了一个阈值的时候，redis会fork一个子进程，父进程继续处理客户端请求，要是在次进程重新期间有新的数据，父进程会将命令加入到旧的aof文件【（保证原文件可用，万一重写失败也不影响恢复）】以及aof重写缓冲区，子进程就负责遍历内存里的数据，把每个 key 的最新状态写成一组最简化的命令，生成一个新的 AOF 文件，当子进程更新完毕之后，会通知父进程，父进程将重写缓冲区累积的新命令追加到子进程的aof文件里面，然后用子进程里面的新的aof文件代替旧的aof文件

**Redis 为什么 AOF 重写用子进程，而不用线程？**

子进程通过操作系统的写时复制可以在不加锁的情况下安全的共享主进程的内存数据，而线程共享内存，没有隔离性，为了解决数据一致性问题因此需要进行加锁操作，这个很影响性能

**redis的rdb持久化：**

rdb快照就是记录某一个瞬间的内存数据，他不向aof是以追加命令的方式，因此在恢复数据的时候会比aof快一点，但是他的快照是全量快照，那么速度就会慢一些，因此不能频繁进行快照操作，一般是设置一定时间保存快照，也因为他是全量快照，因此一般不是在主线程中去进行的，而是fork一个子进程，他和父进程共享一个可读物理内存，子进程将物理内存的数据写入到rdb,但是要是此时父进程可能还在继续写操作，这些数据只能等待下一次进行快照的时候存入rdb了，要是在这个期间父进程宕机了，那么他这个时间段的数据会消失，而且他还有一个缺点，就是在子进程进女性快照的时候，要是父进程对于每个物理页都进行了写操作，那就代表需要两份物理内存，这样对于内存来说也是一种消耗

目前redis采用的是rdb和aof的结合体，前半部分用rdb进行快照，这样恢复会比较块，后半部分用aof，这样丢失的数据会比较少

ai:

Redis 提供两种持久化方式：**RDB** 和 **AOF**。
 RDB 是定期把内存数据生成快照保存到磁盘，优点是文件小、恢复快、性能影响小，但可能丢失几分钟的数据；
 AOF 是把每次写操作以日志形式追加到文件，数据更安全、可读性强，但文件更大、写入开销更高。
 通常生产环境会同时开启两种方式，既利用 RDB 的快速恢复能力，又通过 AOF 提高数据可靠性，Redis 重启时也会优先加载 AOF 文件，因为它的数据最新。

**redis的热点key问题**

redis热点key问题主要出现在秒杀场景，因为所有的客户端请求都会达到同一个商品库存key上面，导致单节点qps【Queries Per Second】突然飙升，容易把redis打爆，因此我会从下面这几个角度解决

可以从数据分片，二级缓存，缓存预热，限流降级和业务优化方面考虑

数据分片：不能只用一个库存key,可以把库存进行分片操作，请求按照用户id或者随机数分配到不同分片上面。

二级缓存：应用服务先维护小范围的本地计数器，现在本地进行扣减，在批量写回redis

缓存预热：在系统启动前，主动将热点数据加载到redis中，避免第一波大流量把后端db【database】打爆

限流降级：限流：在应用层使用漏桶，令牌桶等限流算法，控制访问热点key的并发速率；熔断降级：在redis出现热点问题时，通过熔断降级机制直接返回“已卖完“或者请排队，保护后端

漏桶（Leaky Bucket）：顾名思义，就是有漏洞的桶，通的漏洞的大小是一定的，因此流出速率时一定的，要是加太多的水，就会从上面溢出，这写直接不管。比如说，系统1秒可以触发100个请求，要是现在来了200个，也只能处理一百个请求

令牌桶（Token Bucket）：桶里有一定的令牌数量，以固定速率向桶里面加令牌，要是来了请求必须先在桶里拿取令牌，因此要是拿取的少桶里面会存有一部分令牌可以应对突发流量

**redis的大key问题**

首先为什么大key很危险，首先他占用很大的内存，那么很可能导致oom;对于大key的操作会阻塞redis主线程，应先其他请求；大key也会产生大流量，占用网络宽带

解决方法：要是大key是集合型，比如说是list/hash/set/zset,将一个大key拆分成多个小key；合理使用数据结构，当使用list/hash/zset的时候，操作复杂度是o(N),那么可以对他进行分页或者批量处理；然后对于大key,还可以在在应用层开启一个线程异步进行处理；

**大key中如果是map结构，其value如何进行压缩**

**Redis 渐进式扩容**

redis集群有1万六千多个槽，每个key根据crc(key)%槽的数量映射到某个曹，而槽是以分片的形式分在各个节点中，当新增一个节点的时候，按道理来说应该会把之前节点里面的部分槽分配给新节点，但是他不是一次性将这个节点的槽移动过去的，防止卡死redis主线程，采用渐进式迁移，在迁移的过程中,在下面

迁移的过程是这样的：一个槽要从节点a迁移到节点b,那么会在节点a上面把该槽标记为migrating,在节点b上面把该槽标记为importing,然后分批把a中该槽的key搬到b，此时有三种状态，你要访问的槽完全属于a,那就是还没有开始迁移，那么客户端访问的时候直接返回就可以了；要是槽中的key正在进行迁移，那么此时a节点的槽被标记为migrating,b节点的该槽会被标记为importing,此时客户端访问key,会先在a中访问，要是在就获取到了，要是不在a节点会返回客户端ask告诉该key已经移动到b节点中去了，那么客户端就会去b节点中找，在迁移前面每次都是这样；要是该槽成功完成迁移了，那么现在该槽完全属于b节点，此时客户端初次去a节点访问，此时会返回给客户端moved表示已经前已完成哪个，那么客户端之后都会去b节点查找并更新槽和节点的映射关系

Redis 为什么用TCP

redis使用tcp,因为他需要可靠，有序的连接，redis命令必须保证不丢失且按照顺序执行，tcp提供了重传机制和和顺序保证，要是使用udp,redis的单线程顺序执行就会被破坏

**那三个以及解决方法**

缓存穿透：查询的数据在缓存和数据库都不存在，所有的请求都会打到db

解决方法：对参数进行校验，非法请求的话直接拒绝

缓存击穿：某个热点key在ttl到期瞬间失效，此时大量的请求都发往db,到只db压力过大；

解决方法：使用互斥锁，第一个请求刷新缓存，其他请求等待；或者可以体提前刷新，在快过期的时候就主动刷新缓存；

缓存雪崩：大量缓存同时过期，导致都打到了db上面，导致db压力过大

解决方法：缓存ttl随机化，这样可以避免多个key同一时间过期；

**讲一下Redis怎么实现固定窗口的限流的**

固定窗口限流是最简单的一种限流算法：把时间划分为一个个固定的窗口，每个窗口内允许的请求数有限，要是超过就拒绝请求

redis实现的方式：原子自增(incr)+过期时间(expire),主要流程是首先将用户id和当前窗口时间辍【取整到窗口的起始时间戳，就是在阈值范围内，就对应的是一个相同的时间辍】并接key,调用incr key,对计数器+1,要是在时间窗口里没有，就设置一个并加上他的过期时间【就是窗口大小】，然后每次请求这个key的就会将他进行原子自增，要是大于阈值就会拒绝，要是超过了过期时间就会删除这个时间窗口

举例：窗口大小=10 秒

- 12:00:03 → 窗口起始戳=12:00:00
- 12:00:09 → 窗口起始戳=12:00:00
- 12:00:12 → 窗口起始戳=12:00:10

固定窗口先流的缺点：在窗口交界处可能存在瞬间通过超过阈值的流量。假设窗口大小是1秒，阈值是00,要是在第一个窗口的最后一毫秒打了100次，然后在下一个窗口最开始1毫秒又打了100个请求，这样子的化两次加起来几乎在一秒内通过了200请求

解决方法：滑动窗口...

怎么用Redis实现分布锁

**redis的主从复制：**

它主要分为两种模式，同步复制和增量复制

从节点刚上线，会向主节点发送PSYNC命令请求全量复制，主节点生成rdb快照发送给从节点，从节点接收到快速和主节点状态同步，之后每个主节点维护了一个复制缓冲区，每次有请求时，主节点会将命令放在复制缓冲区，然后从节点从复制缓冲区去数据，要是从节点短暂的出现了宕机然后恢复，可以通过复制缓冲区获取期间的增量命令

**Redis有哪些常用的数据结构？你自己在项目中用过哪些？**

string,hash,list,set,zset这些的；string可以存储数字字符串，比较适合计数器，分布式锁；hash是键值对集合，适合存储结构化数据，list他适合有序，可重复的字符串列表，比较适合用于消息队列；set他比较适合无序，不可重复，常用于去重，查找共同好友等；zset每个元素都带有一个分数，常用于排行榜

**string底层原理？**

redis的string类型并不是简单的c字符串，而是基于sds实现的【simple dynamic string】结构实现的；sds他是一个带有数据头的动态字符串结构，结构体里面大概会有len当前字符串长度，zlloc分配的总空间大小，buf真正存放字符串内容的数组；

他相对于c字符串有这几个优势：获取字符串长度更加简单，他通过len记录了字符长度，因此不用像c字符串那样进行遍历操作；采用了惰性释放的原理，在缩短字符串的时候不会立即释放内存，减少了内存分配的次数；因为他是通过len来知道具体什么时候结束的因此可以存放二进制数据

**zset底层原理？为什么这样设计，就能排序？必须详细说出来？**

zset底层是通过是通过跳表+哈希表的组合实现，跳表负责按score维护一个有序的结构；哈希表负责o(1)的按成员进行查找；对于比较，会先比较score,要是相等就在比较member的字典需来进行排序

**Redis如何与数据库保持双写一致性?**

因为redis是作为缓存层的，而数据库作为持久化层，当我们同时更新redis和数据库时，可能会面临这个问题，我目前想到的方法是cache aside和延迟双删；对于cache aside主要是对于读操作优先读取缓存，要是是写操作，一般是先更新数据库然后在删除缓存，这样在下次读取次数据的时候会直接打到数据库然后更新到缓存；【但是这样存在短暂不一致问题，就是假设线程a对取数据，线程b更新数据，在并发操作下，a线程读取数据是发现缓存中已经没有了，就会去数据库中拿取的时候b线程已经将数据从缓存中删除，拿到了旧值并将旧值写入缓存的时候b线程将新值写入了数据库中，那么就出现了缓存写入的是旧数据，数据库是新数据的问题，】所以他比较适合读多写少的情况，为了避免这种情况，就可以采用延迟双删策略，就是先更新数据库，然后噢删除缓存中的数据，然后延迟一段时间后在将缓存中的数据进行删除

**redis的哈希槽**

redis集群使用1万6前道格哈西曹来进行所有key的分片操作，每个节点都会有几个哈希槽，redis的key根据crc16算法取模得到对应的哈希槽，然后得到不同的节点，这样可以保证key的均匀分布，在节点进行增删时，就只需要易懂向对应得槽就行了，实现了水平扩展

**哨兵模式**

它主要是为了解决高可用，负责监控redis主从节点的状态，在主节点宕机是自动进行故障转移。具体是这样：他会定期监测主节点和从节点是否正常，当主节点不可用的时候，选举一个从节点升级为主节点，并让其他从节点指向新的节点，然后还需要通知客户端，让他获取最新的主节点

首先哨兵集群，他们各个节点都是平等的，但是当一个哨兵节点发送有一个redis主节点宕机是，他就会将这个消息发送给其他的哨兵节点，要是他们超过一半说这个redis主节点确实宕机了，那么他会认为这个redis主节点客观下线，那么现在哨兵集群就会开启选举，选出一个leader,这个leader负责进行这redis的故障转移，转移完之后哨兵集群就回复没有leader的情况，人人平等

redis geo怎么使用

**mysql和mongodb区别**

mysql是关系型数据库，基于行，列表之间；mongdb是文档型非关系型数据库，基于json文档



**Redis 分布式锁的实现思路：**

1. **加锁原理**
   - 客户端通过 `SET key value NX PX expire` 获取锁，其中：
     - `NX` 确保只有当 key 不存在时才能成功设置 → 原子性保证只有一个客户端拿到锁。
     - `PX expire` 给锁设置过期时间，防止客户端崩溃导致死锁。
   - 拿到锁的客户端可以安全操作共享资源，其他客户端需等待或重试。
2. **防止误删锁**
   - 问题：客户端 A 获取锁后操作未完成就崩溃，锁被释放，客户端 B 获取锁，如果此时客户端 A 的后续操作执行了 `DEL key`，可能把 B 的锁也删除 → 出现误删。
   - 解决方法：锁的 `value` 设置唯一标识（如客户端 ID 或 UUID）。释放锁时先检查 `value` 是否等于自己，只有匹配才执行删除，这样不会误删其他客户端的锁。
3. **锁过期刷新（Watchdog 看门狗机制）**
   - 如果业务操作较长，可能在锁过期前未完成。
   - Redisson 等客户端实现了“看门狗”，会在客户端持锁期间不断延长锁过期时间，保证操作完成前锁不会被 Redis 自动释放。

但是redis不是单线程的吗为什么还要加锁，redis确实时单线程的，他加锁主要时为了协调多个客户端对共享资源的访问。

**redis一定是单进程单线程吗？**

Redis 在**核心命令执行上是单线程的**，避免了锁竞争和线程切换问题，但它仍使用子进程/后台线程处理持久化、过期清理等异步任务，网络 I/O 则由事件循环异步处理。

**redLock？**

分布式锁，主要是在多个redis节点之间保证锁的安全性和可靠性。比如说部署了5个redis节点，那么客户端会在这5个节点上尝试设置所，要是有超过一半成功了，那就获取锁成功

**redis为什么快？**

i/o多路复用

是一种在单线程或者单进程同时监控多个i/o对象是否可读，可写，发生异常的技术。

他避免为每个连接创建独立线程阻塞等待，从而在高并发下用较少的线程处理大量的连接

**滑动窗口限流怎样用redis解决？**

滑动窗口限流核心就是在任意时间窗口内只允许N个请求。可以用zset来实现

具体做法：以用户为key,每次请求时，用当前时间戳作为score,向zset查一条数据，然后删除掉窗口之外的就数据，在检查zset的元素数量，要是超过阈值就先流，否则就保存

**布隆过滤器用redis的什么数据结构实现**

string类型+位图实现











































