kmesh

## Kmesh-ebpf

##### 介绍你做了啥

kmesh是一个基于ebpf技术的服务网格数据面开源项目，目的是为了解决传统服务网格在性能损耗和资源占用上的缺点，他的核心创新点是通过ebpf在内核层实现流量拦截和服务治理，绕过了用户态代理，实现接近原声网络的性能。由于对于ebpf程序缺乏单元测试导致代码质量风险高，迭代效率低，我的任务主要是实现对sendmsg和cgroup两类关键内核态程序的测试用例，sendmsg主要是检测在收发消息时在消息头前加的tlv格式内容是否正确，cgroup分为cgroup_skb和cgroup_sock的实现，cgroup_skb主要是检测数据包并在特定情况下触发发送日志，cgroup_sock主要是在 **新建连接时** 做服务发现 & 负载均衡，主要检测连接时是否正确 **重定向目标地址**，负载均衡策略是否生效，我的测试主要的测试是用c和go编写的，c代码主要负载Mock无法触发的程序，go代码主要通过真实网络行为来验证Ebpf处理结果是否符合预期。

##### ebpf程序

疑问：有了ebpf为什么减少了上下文切换，把没有和有的整个流程详细写出来

传统的服务网格：客户端通过系统调用connect/send,然后到达内核网络栈，通过iptables规则拦截，重定向到envoy sidecar用户态，然后用户态进行envoy处理，比如服务发现呀，负载均衡呀，经过一系列处理后有发送到内核网络栈，然后有内核网络栈将数据进行发送

加入ebpf之后：客户端通过系统调用connect/send达到内核网络栈，在内核网络栈中不同阶段会触发相应的ebpf程序，比如说connect阶段会触发cgroup_sock进行服务发现和负载均衡，sendmsg阶段会触发sendsg进行数据包修改，数据包流动阶段会触发cgroup_skb进行监控，在触发的ebpf程序里面进行相应的服务发现呀，负载均衡的处理，人处理完成后内核网络栈将数据进行发送，就没有回到用户态的上下文开销

sendmsg.c

主要就是在客户端通过waypoint发送数据是，采用tlv格式编码将原是目标地址信息嵌入到发送的数据包中

测试流程：首先加载ebpf程序到内核，然后从内核中获取关键组件，socket哈希表和sendmsg程序，然后将sendmsg程序挂载到socket哈希值上面，并且挂载的时候将挂载类型设置为socket消息发送时触发。之后就是进行的真实触发流程：通过创建tcp服务器，本地客户端进行dial连接可以获得连接的socket文件描述符，然后将这个文件描述符插入到socket哈希中，然后在向连接写入数据，在写入数据时，内核就会发现这个连接的socket挂载在socket哈希上面，而这个sendmsg程序被挂载到sockhash map上，那么就会触发sendmsg这个ebpf程序的执行，在数据前面加上Tlv，将修改后的数据发送给服务器，然后服务端进行接收并验证tlv格式是否正确

cgroup_skb

主要是实现了细粒度的流量监测，同时监控被kmesh管理的流量的入口和出口，进行周期性监控报告

测时流程：首先加载ebpf程序到内核，直接将这个ebpf程序挂载到cgroup上面，然后将本地ip加入到kmesh 管理的map中，然后建立tcp连接，在建立tcp连接时，tcp的握手就会有数据包的产生，因为进程挂载的是cgroup,所以所有的数据包都会被拦截，但只有被kmesh管理的IP的数据包才会触发监控，程序会先检查数据包是否来自kmesh管理的IP，要是时就触发监控并通过ring将监控数据上传，然后在测时端从ring buf中读取监控数据

cgroup_sock

在新建立连接时实现服务发现和负载均衡，主要实现了流量的拦截和重定向

测试流程：首先是加载ebpf程序到内核，直接将这个ebpf程序挂载到cgroup上，然后将本地ip加入到kmesh管理的map中，然后在测试测试端事先将本地ip加入到frontend_map的key,要是service设置了waypoint,那么就直接重定向目标到waypoint ip.port,要是没有，那么会根据service结构体里面的lb_policy进行选择，比如随机选择后端，本地优先必须取本地，本地优先失败后退回远程

**kmesh目前完取那可以代替sidecar吗？**

kmesh目前还不能完全代替sidecar,他目前确实是在追捕覆盖传统的树局面的核心能力，比如在l4层上的连接拦截，负载均衡，流量转发，监控等能力已经比较成熟，比如sockops,sendmsg,cgroup_skb,cgroup_sock这些ebpf程序就能完成连接路由，请求诸如，指标上报等功能。

但是在l7层上的复杂功能，比如http/grpc的内容级路由，请求重写，熔断，限流，认证全等，目前主要依赖用户太组件，比如说istio,因此我觉得他目前是处于发展阶段，可能后续完善了这些功能就有完全代替sidecar的潜力

**ebpf程序是怎样加载到内核的？**

首先就是使用clang把ebpf源码编译成.o文件，这个文件里包含了多个section,比如"sk_smg/sendmsg","cgroup_skb/ingress"等，然后我是在

你在编写ebpf程序的时候又遇到什么问题吗？

在进行测试的时候，因为他牵扯到ebpf索引不太好测试，我是通过将bpf_trace_printk()封装成一个多参数调用的宏，在ebpf程序中像刚开始找bug一样将他的内容打印出来进行检查是否正确













