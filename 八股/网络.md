网络

##### @@@@@tcp/ip协议栈

tcp/ip协议栈分为4层：从上到下是：应用层，传输层，网络层，链路层

应用层：就是我们直接接触到的应用协议，比如http/https

传输层：实现端到端的通信，比如tcp/udp

网络层：解决新值和路由的问题，比如ip

链路层：负责同一链路上传输数据，比如以太网，wifi等

**@@@@@应用层调用 send() 到内核 TCP/IP 协议栈发送数据全过程**

当用户态调用send/write函数，这属于系统调用会先入内核，进入内核socket层，在socket层，内核会检查socket类型以及socket是否已经连接，发送的数据在缓冲区是否有空间，然后检查完毕就进入了tcp协议层，tcp会将数据根据mss大写分割成报文段，在数据前面加上tcp首部，比如说源端口，目的端后，序号，确认号等等，然后将数据放入发送缓冲区，然后就到了ip层，ip层给每个数据包前面都加上ip首部，然后到了链路层，封装以太网帧，然后调用网卡驱动的dma,把数据放到往卡的发送队列，然后网卡从队列取出数据，发送无线电波，对端网卡收帧，然后在层层上交

**@@@@@那么对于socket，面试管可能会问，你在写你的项目的时候遇到socket相关的问题了吗？**

在刚开始写socket的时候，accept/recv默认时阻塞的，导致服务端被某个客户端卡住了，然后我给socket设置了非足色结合epoll做o多路复用。还遇到了一个端口服用的问题，我当时在调是阶段，需要频繁开启服务器，他会提示我端口被 TIME_WAIT 占用的信息，解决的方法就是在bind前设置so_resureaddr,这样就可以实现端口复用

##### @@@@@tcp中序列号和应答号的理解

首先就是tcp是面向字节流的，那么他就可能有乱序问题，为了解决这个问题，发送的数据就会进行编号。序列号是对字节流里的每个字节编号，比喻应用层发了1000个字节，tcp会给每个数据包的第一个字节一个序号，后面一次递增。这样就算底层分片乱序到达，接收方有恩哪个按扎序列号进行重组。

确认号是接收方在ack里面带的一个字段，表示的是下一个期望收到的字节序号，比如确认号是501,那么就说明1-500字节都收到了，接下来要从501开始

**@@@@@键入url发生什么？**

当用户在浏览器输入url并回车，浏览器会先检查缓存，要是缓存没有命中就通过dns解析得到服务器ip,然后发起tcp三次握手，要是是https还会进行tls握手，简历链结构发送http请求，请求会经过网络传输到达服务器，服务器处理后返回响应，浏览器收到响应后解析html,加载css和js,构建dom树和渲染树，最后经过布局和绘制，把页面成先到用户平面上

扩展：面时官可能追问：

当用户在浏览器输入url并回车，那么浏览器首先解析这个域名，然后现在本地硬盘的hosts文件中找看是否有和这个域名对应的ip,要是有就直接使用host文件里的ip地址，要是没有，那么浏览器会发出一个DNS请求到本地DNS服务器，本地DNS服务器会首先递归查询他的缓存记录，要是有就直接返回，要是没有，本地DNS服务器还要向DNS根服务器进行查询。根DNS服务器没有具体的域名和ip的对应关系，他负责告诉本地DNS服务器，你可以到域服务器上去查询，并把域服务器地址给他，那么本地DNS服务器继续向域服务器发出请求，请求对象是.com域服务器，.comm域服务器收到请求后，也不会直接给他域名相对应的ip,而是告诉本地服务器他的域名的解析服务器的地址，最后，本地DNS服务器向域名的解析服务器发送请求，这时就能收到一个域名和ip地址的对应关系，本地DNS不仅要把ip地址返回给电脑，还要将这对应关系存在缓存中，给下一次使用。拿到ip地址之后，浏览器会随便选择一个端口向服务器web程序80端口发起tcp连接，这个连接到达服务器后，进入网卡，然后进入内核的tcp/ip协议栈，最终到达web程序，最终通过三次握手建立tcp/ip连接，然后发起一个http请求，

**@@@@@http和https的区别**

http是明文传输协议，数据在客户端和服务端之间传输不会加密，容易被中间热门窃取，安全性较差；https在http上加了ssl/tls协议，通过对称加密，非对称加密，数字证书来保证数据的安全性；同时，https使用数字证书来验证服务器身份，反正伪造。

**@@@@@那么现在还会有http的使用吗？**

HTTPS 确实是主流，但在一些 **安全要求不高、受控的场景** 仍然会用 HTTP,比如，在一个完全受控的内网环境，对性能敏感又不强求加密；在本地调是或者测试阶段，为了避免证书配置复杂性，开发者也会用到http;在静态资源发恶梦发的内部链路上，为降低开销也可能用http

**@@@@@讲一下lts的4次握手？**

tls的四次握手是在tcp建立连接后进行的，首先客户端发起ClientHello,告诉服务器自己支持的协议版本，加密方法，压缩方法和一个随机数；然后服务端返回ServerHello,确认使用的协议版本，选择合适的加密算法并带上自己的证书和随机数；接着客户端验证证书合法性，，并生成一个pre-master secret预主密码，用服务端的公钥进行非对称加密后发送给服务器，服务端通过私钥解密得到预主密码，那么现在客户端和服务器都有三个随机数，双方基于三个随机数和协商算法算出会话密钥，之后的通信都是使用这个会话密钥来进行加密和解密。最后，双方各自发送 ChangeCipherSpec 和 Finished 消息，确认加密通道建立成功，此后通信就使用对称加密保证安全和效率。

**@@@@@交换机？**

交换机是一种工作在数据链路层的网络设备，他通过学习MAC地址并建立MAC地址表来实现数据真的定向转发，同时交换机支持全双工通信和VLAL划分在大型网络中创用三层交换机结合路由器功能哪个时先更复杂的转发

**@@@@@rpc和http的区别，rpc比http的优点**

http是应用层协议，定义了客户端和服务段之间请求和响应的传输规则；而rpc是一种远程调用方式，他让一可以向调用本地函数一样去调用远程服务的方法，rpc通常会基于底层传输协议并结合高效的序列化方式，相比传统的http文本传输更轻量高效

**@@@@@http1.0和http2.0的改进**

http1.0相比于http1.0主要改进有多路复用：一个tcp链接可并发多个请求，避免队头阻塞；二进制分帧；压缩头部；服务器可主动向下发资源减少延迟

**头部压缩的方式有哪些？**

http/2使用HPACK算法来实现头部压缩。他主要有两个特点：静态表和动态表：维护一张头字段表，把常见的头用索引代替，大大减少了重复传输。Huffman编码：对字符串部分进一步压缩，用更短的二进制码表示高频字符

**@@@@@tcp和udp的区别**

tcp是一种面向连接可靠的传输层协议，通过三次握手建立连接，并提供确认应答，超时重新传输，流浪控制和拥塞控制，保证数据按顺序不丢失的传输，传输过程中，每个数据段都有序号，接收方会返回确认应答（ACK），如果发送方在超时时间内没收到确认就会重传；同时 TCP 会对乱序到达的数据进行重新排序，保证按序交付；此外还通过**流量控制**（滑动窗口避免接收方被冲垮）和**拥塞控制**（慢启动、拥塞避免等算法防止网络过载）来确保传输的可靠性和稳定性。而udp是无连接的，不保证可靠传输，开销小，速度快，常用于视频通话，直播等场景

**@@@@@tcp的三次握手**

第一次客户端发送SYN包请求建立连接，第二次，服务段收到后回复SYN+ACK包，包是同意并确认客户端请求；第三次，客户端再回一个ACK包确认，连接正式建立

**@@@@@扩展：为什么需要三次握手？**

为了防止已失效的连接请求报文段突然又传送到了服务端。假设出现了这种情况，那么server发出确认，新的连接就建立，由于现在client并没有发出建立连接的请求，因此不会理财server的确认也不会向server发送数据，但server却以为新的运输连接已经建立，并一直等待client发来数据，这样，server的很多资源就白白浪费。

**@@@@@第三次握手ack丢失？**

**@@@@@tcp的四次回收**

首先，客户端发送FIN包给服务端表示我没有数据要发了，然后服务器会ACK表示收到，但是他可能还有数据没发完，等服务器发完数据后，他在向客户端发送FIN包表述我也没有数据要发了，最后客户端再回ACK确认，连接正式关闭。

**@@@@@为什么建立连接是三次握手，而关闭连接却是四次挥手呢？**

这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。

tcp如何保证可靠传输，也是上面的问题噢

**@@@@@长连接和短连接有什么区别吗？**

他们的主要区别在连接的维持时间上和资源消耗上。长连接是在客户端和服务端简历一次tcp连接后保持一段较长的时间，在这器ian可以复用这个连接发送多次请求，这样可以减少频繁建立连接和关闭连接带来的开销，提高网络效率，适合频繁通信的场景，但是长连接会占用服务器资源，如果连接数过多，可能会消耗大量内存和文件描述符。端连接也就是每次请求都建立新的连接，请求完成后就会断开，优点是链接端，占用资源少，但是要是连接频繁的话会带来额外的开销和延迟，比较适合偶发性场景

**@@@@@MTU是什么？为什么设置为1500字节**

MTU也就是maximum transmission unit,也就是网络层一次能传输的最大数据包的大小，不包括链路层的头部；他的作用是控制每个数据包的大小，避免数据包过大导致的分片，从而导致的传输效率降低以及丢包风险的增加；以太网默认的MTU是1500字节，这个值能一直保持也不是没有他的道理的，肯定兼顾了传输效率和分片开销。

