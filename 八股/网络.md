网络

##### @@@@@tcp/ip协议栈

tcp/ip协议栈分为4层：从上到下是：应用层，传输层，网络层，链路层

应用层：就是我们直接接触到的应用协议，比如http/https

传输层：实现端到端的通信，比如tcp/udp

网络层：解决新值和路由的问题，比如ip

链路层：负责同一链路上传输数据，比如以太网，wifi等

细节：为什么要分层？

分层的目的主要是：降低复杂度，等会面完再写

**osi七层模型，数据怎么从这七层模型中进行一一传输的**

osi七层模型功能

ip功能，ip地址分类以及每类的范围

icmp与ip关系，icmp作用

说说数据链路层的mac地址



**什么是ARP？**

arp【address resolution protocol】，也就是地址解析协议，将一个ip地址解析成mac地址的协议，在网络层和数据链路层之间，主要是为了局域网内主机间通信是找到目标主机的物理地址。

细节：

他是一种无连接协议，不依赖tcp/udp,直接封装在以太网帧中

arp请求时广播的，所以只能在广播域种使用，跨网端需要通过路由器【网关】来实现

细节：具体工作流程：主机A想给B发包，A查自己的arp缓存表，标识没有找到b ip地址对应的mac，就发出一个arp请求广播，所有局域网中的主机都能收到广播，只有目标ip会单播恢复自己的mac,a收到后，会将他存到自己的arp缓存表种，下次找直接就能在自己的arp表中找到了

细节：可能会追问：arp欺骗是什么？

arp欺骗时一种利用arp协议漏洞进行网络攻击的手段，主要就是通过伪造arp报文包，篡改目标设备的arp环簇表，导致网络流量被劫持

攻击者c向欺骗网关b,那么c会向a发送伪造的arp应答：网关b的ip对应的mac时c的mac，那么后续经过主机a的要发往网关的流量会被转发到c

那么此时网关的通信数据会经过攻击者c

**tcp和udp的区别**

首先tcp是面向连接的，他需要先进行三次握手才能进行数据的传输，udp不需要

tcp他是端对端的，但是udp可以是一堆一，也可以是一对多

tcp他是基于字节流的传输，udp是面向报文的传输

tcp有序列号，应答好来确保数据有序传输，udp可能会发生丢包和乱序的问题

tcp有拥塞控制流量控制等机制，他可能会在网络抖动的情况下会发生传输效率低，udp他不会出现这个问题

因此tcp可能比较慢，但是安全可靠，比较适合文件传输，网页访问等；udp比较快，可能会出现丢包等风险，比较适合视频通话，直播等

**tcp三次握手的状态变化：**

客户端发送  syn给服务端：客户端closed->syn_sent;服务端listen->syn_rcvd

服务端发送 syn+ack给客户端：服务端状态不变；客户端syn_sent->established

客户端发送 ack给服务端：客户端状态不变；服务端syn_rcvd->established

**tcp四次挥手的状态变化：**

客户端和服务端都可以作为主动结束端，现在假设客户单主动关闭，现在说一下四次挥手

客户端发送 fin给服务端：客户端established->fin_wait1,服务端established->close_wait

服务端发送 ack给客户端：服务端close_wait不变；客户端：fin_wait1->fin_wait2

服务端发送 fin给客户端：服务端close_wait->last_ack;客户端：fin_wait2->time_wait

客户端发送 ack给客户端：客户端time_wait不变；服务端：last_ack->closed

2msl后客户端time_wait变为closed

**@@@@@应用层调用 send() 到内核 TCP/IP 协议栈发送数据全过程**

当用户态调用send/write函数，这属于系统调用会先入内核，进入内核socket层，在socket层，内核会检查socket类型以及socket是否已经连接，发送的数据在缓冲区是否有空间，然后检查完毕就进入了tcp协议层，tcp会将数据根据mss大写分割成报文段，在数据前面加上tcp首部，比如说源端口，目的端后，序号，确认号等等，然后将数据放入发送缓冲区，然后就到了ip层，ip层给每个数据包前面都加上ip首部，然后到了链路层，封装以太网帧，然后调用网卡驱动的dma,把数据放到往卡的发送队列，然后网卡从队列取出数据，发送无线电波，对端网卡收帧，然后在层层上交

**@@@@@那么对于socket，面试管可能会问，你在写你的项目的时候遇到socket相关的问题了吗？**

在刚开始写socket的时候，accept/recv默认时阻塞的，导致服务端被某个客户端卡住了，然后我给socket设置了非足色结合epoll做o多路复用。还遇到了一个端口服用的问题，我当时在调是阶段，需要频繁开启服务器，他会提示我端口被 TIME_WAIT 占用的信息，解决的方法就是在bind前设置so_resureaddr,这样就可以实现端口复用

**@@@@@键入url发生什么？**

当用户在浏览器输入url并回车，浏览器会先检查缓存，要是缓存没有命中就通过dns解析得到服务器ip,然后发起tcp三次握手，要是是https还会进行tls握手，简历链结构发送http请求，请求会经过网络传输到达服务器，服务器处理后返回响应，浏览器收到响应后解析html,加载css和js,构建dom树和渲染树，最后经过布局和绘制，把页面成先到用户平面上

扩展：面时官可能追问：

当用户在浏览器输入url并回车，那么浏览器首先解析这个域名，然后现在本地硬盘的hosts文件中找看是否有和这个域名对应的ip,要是有就直接使用host文件里的ip地址，要是没有，那么浏览器会发出一个DNS请求到本地DNS服务器，本地DNS服务器会首先递归查询他的缓存记录，要是有就直接返回，要是没有，本地DNS服务器还要向DNS根服务器进行查询。根DNS服务器没有具体的域名和ip的对应关系，他负责告诉本地DNS服务器，你可以到域服务器上去查询，并把域服务器地址给他，那么本地DNS服务器继续向域服务器发出请求，请求对象是.com域服务器，.comm域服务器收到请求后，也不会直接给他域名相对应的ip,而是告诉本地服务器他的域名的解析服务器的地址，最后，本地DNS服务器向域名的解析服务器发送请求，这时就能收到一个域名和ip地址的对应关系，本地DNS不仅要把ip地址返回给电脑，还要将这对应关系存在缓存中，给下一次使用。拿到ip地址之后，浏览器会随便选择一个端口向服务器web程序80端口发起tcp连接，这个连接到达服务器后，进入网卡，然后进入内核的tcp/ip协议栈，最终到达web程序，最终通过三次握手建立tcp/ip连接，然后发起一个http请求

细节：域名层级的考核

域名他采用层级化的树形结构，用.分割，最右侧是顶级域名【.com,.cn】，往依次是二级域名，三级域名等，最左侧是具体的主机名

比如：www.baidu.com

最右侧的.com是顶级域名，中间的百度是二级域名，最左侧的www是主机名，用于指向提供网页的服务器，他会根据功能而变，不是固定的，比如说是邮箱服务器又可能是mail.baidu.com

**dns基于udp有什么问题？，基于tcp的dns你知道吗**dot doh

**@@@@@http和https的区别**

http是明文传输协议，数据在客户端和服务端之间传输不会加密，容易被中间热门窃取，安全性较差；https在http上加了ssl/tls协议，通过对称加密，非对称加密，数字证书来保证数据的安全性；同时，https使用数字证书来验证服务器身份，反正伪造。

**https会加密url吗**

**@@@@@那么现在还会有http的使用吗？**

HTTPS 确实是主流，但在一些 **安全要求不高、受控的场景** 仍然会用 HTTP,比如，在一个完全受控的内网环境，对性能敏感又不强求加密；在本地调是或者测试阶段，为了避免证书配置复杂性，开发者也会用到http;在静态资源发恶梦发的内部链路上，为降低开销也可能用**http无状态**

http是无状态协议，就是服务器不会主动保存客户端的状态，每次请求都是独立的。

首先http他是超文本传输协议，是追求高效的，要是每次服务器需要保存客户端的状态，那么会消耗服务端大量内存

每次客户端发送给服务端的消息，都包含所有必要的消息，是独立的

**那要是你需要让服务器记住客户端应该怎么办？**也就是问的**HTTP无状态，那么如何保存用户登录状态？**

这就需要在http上增加状态保持机制，具体做法

cookie:由服务端下发给客户端，客户端每次请求自动携带，服务器的通过cookie来识别客户端的消息

session:服务器保存状态信息，他会在session中客户端发来的cookie里面的session id是否存在，要是存在就可以时别出客户端

**http和socket连接区别**

socket他不是协议，是操作系统提供的网络工具，主要是在应用层和传输层之间的编程接口，支持tcp的长连接和udp的无连接通信，建立连接后双方可以发送字节流，适合及时通信，在线游戏这种高频交互场景。http是应用层协议，主要是基于tcp和socket实现的，一般遵循客户端请求-服务端响应这种单向模式，是无状态的，更适合网页浏览等场景

**http的报文结构**

**请求报文：**

请求行：请求方法+url路径+协议版本

请求头部：一般是由多个键值组成

空行：隔离请求头和请求体

请求体：可以选择，一般存放数据结构

**响应报文：**

状态行：协议版本+状态码+描述

响应头部：多个键值对组成

空行：：隔离响应头和响应体

响应体：服务器返回的实际数据

**get和post的区别**

最大区别：查数据用get,提交或者修改数据用post

表达含义不同：get是获取资源。主要是服务器查圩数据，对服务起来说是安全的；post是提交资源，也就是会向服务器发送数据，会改变服务器的数据可能不安全

数据传输方式不同：get数据是通过url来进行传输的；post:数据是通过请求体来进行传输的

**@@@@@讲一下lts的4次握手？**

tls的四次握手是在tcp建立连接后进行的，首先客户端发起ClientHello,告诉服务器自己支持的协议版本，加密方法，压缩方法和一个随机数；然后服务端返回ServerHello,确认使用的协议版本，选择合适的加密算法并带上自己的证书和随机数；接着客户端验证证书合法性，，并生成一个pre-master secret预主密码，用服务端的公钥进行非对称加密后发送给服务器，服务端通过私钥解密得到预主密码，那么现在客户端和服务器都有三个随机数，双方基于三个随机数和协商算法算出会话密钥，之后的通信都是使用这个会话密钥来进行加密和解密。最后，双方各自发送 ChangeCipherSpec 和 Finished 消息，确认加密通道建立成功，此后通信就使用对称加密保证安全和效率。

那么延伸，那他用的是加密还是非加密？

在握手阶段，他是通过非对称加密加密的，因为客户段没有服务器的私钥，因此他使用服务器的公钥来进行加密，加密后服务端会会用他的私钥对pre-master secret进行解密；之后是通过对称加密，也就是此时双方都有per-master secret+随机数算出的session key【会话密钥】，然后会根据对称加密比如说是aes来进行加密，进行大量数据的传输

**@@@@@交换机？**

交换机是一种工作在数据链路层的网络设备，他通过学习MAC地址并建立MAC地址表来实现数据真的定向转发，同时交换机支持全双工通信和VLAL划分在大型网络中创用三层交换机结合路由器功能哪个时先更复杂的转发

**交换机和路由器的区别**

工作层次不同：交换机他是工作在数据链路层，主要是识别mac地址，用于局域网；路由器工作在网络层，它主要是识别ip地址，一般是跨网端通信

功能不同：交换机主要是为了多个设备之间的通信；路由器主要是转发和路由的功能

发送速度不同：交换机主要发送的是数据帧，发送数据速度快；路由器发送的是数据包，发送数据较慢、

细节：感觉这个应该不会被问道：集线器讲一下？他工作在物理层，主要功能是接受一个端口的电信号，直接广播到其他端口

细节：**mac地址和ip地址的区别**

功能不同：mac地址主要是用于统一局域网中设备之间直接通信；ip地址用于不同局域网之间的通信定位

层级不同：mac地址工作在数据链路层，一般是出场时就固定了；ip工作在网络层值中

特定不同：mac地址在全球时唯一的，但是ip地址在不同的局域网中时可以重复的

 **HTTP的状态码有哪些？502、504出现在什么情况？301、302的区别？**

2--【成功】：200成功；201:资源创建成功

3--【重定向】:301：永久重定向；302：临时重定向

4--【客户端错误】：400：请求语法错误；401：未认证；403：无权限；404：资源不存在

5--【服务段错误】：500：服务器内部错误；502：网关无效响应；503：服务不可用；504：网关等待下游服务超时

**@@@@@rpc和http的区别，rpc比http的优点**

http是应用层协议，定义了客户端和服务段之间请求和响应的传输规则；而rpc是一种远程调用方式，他让一可以向调用本地函数一样去调用远程服务的方法，rpc通常会基于底层传输协议并结合高效的序列化方式，相比传统的http文本传输更轻量高效

**@@@@@http1.0和http2.0的改进**

http1.0相比于http1.0主要改进有多路复用：一个tcp链接可并发多个请求，避免队头阻塞；二进制分帧；压缩头部；服务器可主动向下发资源减少延迟

**头部压缩的方式有哪些？**

http/2使用HPACK算法来实现头部压缩。他主要有两个特点：静态表和动态表：维护一张头字段表，把常见的头用索引代替，大大减少了重复传输。Huffman编码：对字符串部分进一步压缩，用更短的二进制码表示高频字符

**@@@@@tcp和udp的区别**

tcp是一种面向连接可靠的传输层协议，通过三次握手建立连接，并提供确认应答，超时重新传输，流浪控制和拥塞控制，保证数据按顺序不丢失的传输，传输过程中，每个数据段都有序号，接收方会返回确认应答（ACK），如果发送方在超时时间内没收到确认就会重传；同时 TCP 会对乱序到达的数据进行重新排序，保证按序交付；此外还通过**流量控制**（滑动窗口避免接收方被冲垮）和**拥塞控制**（慢启动、拥塞避免等算法防止网络过载）来确保传输的可靠性和稳定性。而udp是无连接的，不保证可靠传输，开销小，速度快，常用于视频通话，直播等场景

##### @@@@@tcp中序列号和应答号的理解

首先就是tcp是面向字节流的，那么他就可能有乱序问题，为了解决这个问题，发送的数据就会进行编号。序列号是对字节流里的每个字节编号，比喻应用层发了1000个字节，tcp会给每个数据包的第一个字节一个序号，后面一次递增。这样就算底层分片乱序到达，接收方有恩哪个按扎序列号进行重组。

确认号是接收方在ack里面带的一个字段，表示的是下一个期望收到的字节序号，比如确认号是501,那么就说明1-500字节都收到了，接下来要从501开始

**tcp怎样保障可靠连接的？**

首先tcp是面向连接的协议，他会先进行**tcp三次握手**之后才发送树苴

通过序列号保证接收端可以按序重组数据，同时通过校验和监测数据在传输过程中是否损坏

**确认应答机制和重传机制**，接收方在收到数据后会向发送方发送一个ack，要是发送方在超时没有收到数据，会进行超时重传

通过滑动窗口动态调整发送速度，增加流量控制

还有拥塞控制来监测网络拥塞状态，就像慢启动，拥塞避免，快重传，快恢复

**那么追问，tcp的优化方式拥塞控制和超时重传对性能有什么影响码？**



**如何基于udp实现可靠传输？**

udp本身是不可靠的协议，他不保证数据的到达，顺序和去重，但是我们可以在应用层自己实现可靠传输机制，集体实现方法如下

序号机制：给每个udp包加上递增的序号，可以防止乱序问题

ack确认：接收方在收到报后返回确认ack,发送方才认为成功

超时重传：发送方设置超时定时期，要是在这个时间之内没有收到ack那么就重新发包

滑动窗口：控制发送速率，避免接收端处理不过来的问题

扩展：**追问quic【quick udp internet connections]，quic如何做到稳定。**

quic是google提出的，在udp的基础上，融合了tcp可靠性机制，并解决了传统协议的一些缺点

在udp基础上面建立可靠的传输机制：

有序号和确认应答号，解决了丢包和乱序的问题

实现拥塞控制和流量控制：在出现网络抖动的情况下自动降速，避免了过渡丢包的问题

解决了传统tcp的堆头阻塞的问题：

在传统tcp中，他的多路复用是单流传输，所有的数据在一个连接里面串行发送，以单某个数据包丢了，后续的所有包都要等待重传，也就是导致的堆头阻塞问题；码quic的多路复用是基于多流独立进行传输，那么要是一个流的数据包丢失了，只需要重传改流的丢失部分，其他流的数据可以正常的继续传输，这种更加提高了并发请求的稳定性

连接标识的改进：

tcp他是依赖四元组进行连接的，要是设备切换了网络【比如说手机从4G切换到了wifi】，那么连接环直接断开，需要重新进行握手

但是quic是通过连接标识来确定连接唯一性的，完全不依赖ip和端口，那么要是网络设备进行切换也不需要进行重新连接

内置tls加密

tcp要实现lis加密还需要在tls进行3次握手值后在进行tls的4次握手，那么会导致多轮往返，比较耗时；quic是直接将连接和加密合并，在握手阶段直接完成tls的加密，既保证数据的安全又减少了建立连接的延迟

**@@@@@tcp的三次握手**

第一次客户端发送SYN包请求建立连接，第二次，服务段收到后回复SYN+ACK包，包是同意并确认客户端请求；第三次，客户端再回一个ACK包确认，连接正式建立

**@@@@@扩展：为什么需要三次握手？**

为了防止已失效的连接请求报文段突然又传送到了服务端。假设出现了这种情况，那么server发出确认，新的连接就建立，由于现在client并没有发出建立连接的请求，因此不会理财server的确认也不会向server发送数据，但server却以为新的运输连接已经建立，并一直等待client发来数据，这样，server的很多资源就白白浪费。

**tcp头格式有哪些？**

tcp头部长度最小时20字节，也就是160bit,里面主要包含：源端口，目标端口，这两个端口分别是16bit,然后就是序列号32bit,然后是确认号32bit，然后就是tcp头部长度4bit,接着保留了3bit,然后就是9bit的控制位，然后就是滑动窗口大小16bit,接着是tcp校验和16bit，最后还有16bit的紧急指针[他是URG=1有效]，最长可以拓展到60字节

控制位：SYN【建立连接】，ACK【确认收到】，FIN【终止连接】，RST【重置连接】，PSH【数据推送】，URG【数据紧急】，剩下几个好像和阻塞控制有关，但是我好就没看忘了

扩展：能详细讲一下滑动窗口码？

tcp滑动窗口是一种流量控制，主要是用来协调发送方和接收方的处理速度，保证不会因为接收方处理不过来而丢包。他这个16bit的窗口大小主要标识接收方还能接收多少字节，发送方会根据这个窗口的大小来控制发送速率。为什么叫他为滑动呢，因为接收方确认一些数据他的窗口就会往左边滑动，这样发送方就可以发送更多的数据了。发送方的滑动窗口主要有3部分，已发送已确认的数据，那证明接收方已经成功接收到了，那么就可以从发送缓冲区释放；已发生未确认的数据，发送方已经发送但是还没有收到接收方的ack,此时必须暂时保留在发送缓冲区，防止需要重传；未发送但在窗口范围内的数据，可以立即进行发送的数据。滑动窗口一般是和拥塞控制结合使用

滑动窗口 = 流量控制（接收方能力）

拥塞控制 = 避免网络过载（链路能力）

讲一下校验和

它主要的作用就是保证tcp报文在传输过程中数据的完整性。发送方在发送数据前，他会把tcp头部，数据的伪首部【包含源ip地址，目标ip地址，协议号和tcp长度】做16为的反码和，结果放入到校验和字段，然后接收方接收到数据后，会在做一次相同的运算，要是结果不全是1,那么就证明传输来的报文有问题

把数据按 16 位相加，溢出回卷，最后取反

**@@@@@第三次握手ack丢失？**

**@@@@@tcp的四次回收**

首先，客户端发送FIN包给服务端表示我没有数据要发了，然后服务器会ACK表示收到，但是他可能还有数据没发完，等服务器发完数据后，他在向客户端发送FIN包表述我也没有数据要发了，最后客户端再回ACK确认，连接正式关闭。

**可能会三次挥手吗，什么情况？**

他的标准流程一般是四次挥手，因为每一方向另一方向关闭都是独立的，三次挥手有以下情况：

第一方关闭连接之后另一方没有数据要发送。比如说客户端发送了一个fin,然后服务端回了一个ack，此时服务端时没有数据要发送给客户端的，所以客户端就自动进行关闭，也就是进行了两次交互

还有就是半关闭优化：也就和上面一样，就把主动没有数据改成被动没有数据发送，关闭他的fd

**@@@@@为什么建立连接是三次握手，而关闭连接却是四次挥手呢？**

这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。

tcp如何保证可靠传输，也是上面的问题噢

**@@@@@长连接和短连接有什么区别吗？**

他们的主要区别在连接的维持时间上和资源消耗上。长连接是在客户端和服务端简历一次tcp连接后保持一段较长的时间，在这器ian可以复用这个连接发送多次请求，这样可以减少频繁建立连接和关闭连接带来的开销，提高网络效率，适合频繁通信的场景，但是长连接会占用服务器资源，如果连接数过多，可能会消耗大量内存和文件描述符。端连接也就是每次请求都建立新的连接，请求完成后就会断开，优点是链接端，占用资源少，但是要是连接频繁的话会带来额外的开销和延迟，比较适合偶发性场景

 **TCP半连接，全连接，建立完成，哪个阶段最占用内存呢**

我觉得最占用内存的时全连接和简历完成之后，首先半连接他是在服务端收到客户端SYN之后，这个阶段还没又分配到完整的socket结构，占用内存较少；在全连接队列的时候，此时三次握手已经完成了，队列俩面存有完整的socket控制快和tcp缓冲区，占名比半连接明显增加；在建立完连接之后，也就是accept()之后，连接成为一个真正的fd,占用资源我感觉和全队列应该差不多

**@@@@@一个ip段，有四个ip地址，有几个不可用?**

在一个子网里面，全为0的主机号是网络地址，不能分配给主机，还有一个是全为1的主机号，他是广播地址，不能分配给主机，所以一个子网里面，可用地址树是总地址数-2

举例说明：

**网络IO的流程**

一个/29的网络，那么他的子网掩码是：11111111.11111111.11111111.11111000，子网掩码的作用主要是为了判断一个ip是否数以一个子网，要是属于一个子网里面，那就可以进行通信了

假设一个ip:192.168.1.2-------------11000000.10101000.00000001.00000010

​             掩码：255.255.255.248--11111111.11111111.11111111.11111000

​             进行与操作--------------------11000000.10101000.00000001.00000000  → 192.168.1.0



假设子网是192.168.1.0/29,这个子网，先把他的网络号写出来11000000.10101000.00000001.00000   （29 位）

​																				  s               这后面把主机号加上

000 001 010 100 011 110 101 111

a:0        1     2      4     3      6     5       7

那么可用的就是000和111之间的

也就是192.168.1.1/2/3/4/5/6【这里比较好算是因为网络好最后小数点那5位是0】算法：. . . .s+a

首先说一下/后面的数字可以是/0-/32,这里后面的数字主要表示的是一共是32位【为什么是32位】，把数字前面全部设置成1,后面全部设置成0,后面的表示的是主机号，也就是一共有2的32-数字个主机号

**讲讲电脑里的网卡**

网卡全称：网络接口控制器。他的主要作用：

数据格式的转换作用，就是发送数据时，对于电脑的数字转化成电信号进行传输，接收数据，就刚好相反

身份证：每块网卡在出场时，就会户话一个全国唯一的mac地址，相当于是网卡的身份证

特性：有优先网卡和无线网卡【有线网卡需要插网线，无线网卡主要是靠wifi,蓝牙】，之前是处于半双工的特性，目前主流的还是全双工

**@@@@@半双工和全双工？**

半双工：同一时间只能单向通信

全双工：同一时间可以双向同时通信

**什么是四元组**

源ip地址，源端口号，目的ip地址，目的端口号

**@@@@@MTU是什么？为什么设置为1500字节**

MTU也就是maximum transmission unit,也就是网络层一次能传输的最大数据包的大小，不包括链路层的头部；他的作用是控制每个数据包的大小，避免数据包过大导致的分片，从而导致的传输效率降低以及丢包风险的增加；以太网默认的MTU是1500字节，这个值能一直保持也不是没有他的道理的，肯定兼顾了传输效率和分片开销。

常见的网络攻击方式

**TCP 中何时会出现 RST 报文？**

rst报文标识tcp连接出现异常，需要强制复位连接。

比如：

向不存在的端口发送数据：客户端connect到服务器一个没有间题监听的端口，服务器会直接返回一个rst报文

一方已经close后，收到数据会返回rst

应用层调用setsockopt设置立即关闭套接字，此时内核不会走四次挥手，直接发送rst

**已建立连接时客户端突然断电 / 进程崩溃会怎样？**

当客户端突然崩溃或者断电，tcp连接不会里面断开，因为没有fin或者rst,因此服务器刚开始会保持establiehed状态，最后会通过超时崇川才能监测到连接失效，之后服务端会主动关闭自己的连接

ai:

当客户端已经建立连接后突然断电或进程崩溃时，TCP 连接不会立即断开。
 因为此时客户端来不及发送 **FIN**（正常关闭）或 **RST**（异常重置） 报文。

服务器端的 TCP 连接会**继续保持在 ESTABLISHED 状态**，认为连接仍然存在。
 在此期间，若服务器发送数据但一直收不到 ACK，应答超时后会进行多次重传。
 当重传次数达到上限，或启用了 **TCP Keepalive / 应用层心跳检测** 时未收到响应，
 内核或应用层就会判断连接已失效，然后**主动关闭连接**。

**ping的整个流程？**

ping是基于icmp的网络连通测试工具，用来监测目标主机是否可达，网络延迟的问题，主要工作在网络层。比如你现在ping  www.qq.com,那么首先通过dns将域名解析成ip地址，【因为他是工作在ip层的，无需进行Tcp的三次握手】，然后构造icmp报文，ip头部后面会跟着icmp头部，之后会将这个报文通过arp协议获取目标ip的mac地址，然后通过网卡发送出去。

对方主机收到 icmp echo request后，内核协议栈会时别出他是icmp请求，会同遭icmp echo reply报文通过原路经返回给源主机

ai版本：

“ping 是基于 ICMP 协议的网络连通性测试工具，工作在网络层。
 执行 `ping www.qq.com` 时，首先通过 DNS 将域名解析为 IP 地址。
 ping 构造 ICMP Echo Request 报文，在发送前通过 ARP 获取目标 IP 的 MAC 地址，然后由网卡封装成以太网帧发送出去。
 目标主机收到请求后，内核网络栈识别为 ICMP 请求，并回复 ICMP Echo Reply 报文。
 源主机收到应答后计算往返时延（RTT），判断网络是否连通。
 整个过程基于 ICMP，不经过 TCP 或 UDP。”

**socket不用端口的时候能不能进行数据传输？**

在socket通信种，端口号是传输协议的标识，用于取分同一主机上的不同进程，在我们创建tcp或者udp socket时，系统必须为他分配端口号，否则无法完成传输层的复用和路由。但是要是时原始套接子或者数据链路层套接子，他们直接工作在ip层或链路层发送数据帧，不依赖tcp/udp,因此不需要端口号，比如说ping,他是基于icmp工作在网络层的，用的就是原始套接子，不存在端口

ai:

在 socket 通信中，端口号是**传输层协议（TCP、UDP）**用来区分同一主机上不同进程的标识。
 当我们创建 TCP 或 UDP socket 时，系统必须为它分配端口号，否则无法完成传输层的复用和路由。

但如果使用的是 **原始套接字（Raw Socket）** 或 **数据链路层套接字（比如 AF_PACKET）**，它们直接工作在 **IP 层或链路层**，不依赖传输层协议，因此不需要端口号。

举个例子：
 `ping` 命令就是基于 **ICMP 协议** 的，它工作在网络层，使用的就是原始套接字，因此根本不存在端口号的概念。

**vlan和vxlan？**

vlan是一种二层网络隔离技术，通过在以太网帧李家802.1Q的vlan tag来区分不同的广播域，他的id只有12为，也就是最多有4096个网络，而且只能工作在数据链路层，无法跨越到第三层

vxlan是在网络层，他会把整个数据链路层封装在udp报文，通过三层网络建立隧道，让不同字网的主机看起来好向在一个二层网络里面，他是用24位代替了之前的12位id,可以构建更多网络，对云原省方面比较又好

ai:

VLAN 是一种二层网络隔离技术，它通过在以太网帧里加入 802.1Q 的 VLAN Tag 来区分不同的广播域。
 它的 ID 只有 12 位，所以最多可以支持 4096 个网络（实际可用 1~4094），并且只能工作在数据链路层，不能跨越三层网络。

VXLAN 是一种基于三层网络的隧道技术，它会把整个二层的以太网帧封装到 UDP 报文中（端口号通常是 4789），
 通过三层网络建立隧道，让不同子网的主机看起来像是在同一个二层网络里。
 VXLAN 使用 24 位的 VNI 来取代 VLAN 的 12 位 ID，可以支持约 1600 万个虚拟网络，非常适合云计算和多租户环境。

网络为什么不能从tcp层直接到数据链路层吗？

**相同的服务端ip和端口可以连多个客户端的ip和端口吗？相同的客户端ip和端口可以连多个服务器的ip和端口吗？端口是哪来的？**

tcp连接时通过四元组来唯一标识的

，相同的服务器ip+端口，可以同时连接多个不同的客户端；但是相同的客户端ip+端口，只能同时连接一个服务器ip+端口，这是为了避免冲突

端口是操作系统内核分配的，服务器一般监听固定的端口，客户端的多口一般是内核自动临时分配的

**网关是怎样找到后端服务的？**

对于单体架构，一般是静态配置，网关通过本地配置文件记录后端服务的映射关系，这样一般客户读阿宁全球到达后端服务后，网关解析请求路径，匹配本地配置的服务地址，然后转发请求到对应后端ip:端口

对于微服务架构，一般是通过动态服务发现的方式。一般就是服务启动后就会向注册中心注册自己的网络地址，然后网关从注册中心拉取服务列表，缓存服务名和服务地址之间的映射关系，这样当客户端请求服务时，网关会从本地缓存表中找对应得服务地址，通过负载均衡选择一个地址，然后进行转发请求

**讲一下i/o多路复用，适用什么场景**i/o多路复用是一种管理多个i/o时间的机制，允许单个线程同时监控多个文件描述符的状态，适合高并发网络服务器和大量i/o连接的场景。使用的场景：聊天服务器，需同时处理大量客户端连接

**%%%%%能讲一下select,poll和epoll的关系吗？**

select实现多路复用的方式是将以连接的socket都放到一个文件描述符集合，然后调用select函数将文件描述符集合拷贝到内核里，让内核来检查是否由网络事件发生，检查方式，通过遍历文件描述符的方式，当检测到有事件产生时，将次socket标记为可读或者可写，接着再把整个描述符集合拷贝回用户态里，然后又用户态还需要在遍历找到可读或者可写的socket,然后对他进行处理。

而poll和select的区别就是解决了select1024限制问题，性能上没有什么优化。

那么epoll是怎样做的，epoll在内核中使用红黑数来跟踪所有待检测的文件描述符，红黑数是个高效的数据结构，曾删改一般事件复杂度为logn;epoll具体实现原理，epoll使用事件驱动机制，内核维护了一个链表来记录就绪事件，当某个socket有事件发生时，通过回调函数内核将这个socket加入到就绪事件中，当用户调用epoll_wait函数时，会返回就绪事件列表中的个数，不需要像select/poll那样轮询扫描整个socket集合，达到提高了检测效率

#### ET/LT

\- 使用边缘触发模式时，当被监控的 Socket 描述符上有可读事件发生时，服务器端只会从 epoll_wait 中苏醒一次，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完；一般和非阻塞io搭配使用，程序会一直执行io操作

\- 使用水平触发模式时，当被监控的 Socket 上有可读事件发生时，服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束，目的是告诉我们有数据需要读取；

举例：怎样触发read_event?

Epoll是单线程还是多线程

ai:

- 你的描述完全正确，尤其是对两种模式的核心区别（ET 只通知一次，需一次性读完数据；LT 持续通知直到数据处理完）和 ET 与非阻塞 IO 的搭配必要性（避免数据未读完导致遗漏）的解释，非常到位。

- 可以简单举例：比如客户端发送 1000 字节数据，内核缓冲区接收后，LT 模式下 epoll_wait 会一直返回就绪，直到程序把 1000 字节读完；而 ET 模式下只返回一次就绪，若程序只读了 500 字节就停止，剩下的 500 字节不会再通知，必须通过非阻塞循环读才能确保读完，这样更直观。

  **epoll 如何实现 O(1) 查询速度？** 		 		 			

  通过就绪链表只存储已就绪事件，epoll_wait 只需遍历就绪链表。 	

  **ET 和 LT 的主要区别是什么？** 		 		 			

  LT 在状态满足时反复通知，ET 只在状态变化时通知一次。



