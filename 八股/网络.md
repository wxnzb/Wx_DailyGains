网络

##### @@@@@tcp/ip协议栈

tcp/ip协议栈分为4层：从上到下是：应用层，传输层，网络层，链路层

应用层：就是我们直接接触到的应用协议，比如http/https

传输层：实现端到端的通信，比如tcp/udp

网络层：解决新值和路由的问题，比如ip

链路层：负责同一链路上传输数据，比如以太网，wifi等

**osi七层模型，数据怎么从这七层模型中进行一一传输的**

osi七层模型功能

ip功能，ip地址分类以及每类的范围

icmp与ip关系，icmp作用

说说数据链路层的mac地址



**什么是ARP？**

arp【address resolution protocol】，也就是地址解析协议，将一个ip地址解析成mac地址的协议，在网络层和数据链路层之间，主要是为了局域网内主机间通信是找到目标主机的物理地址。

细节：

他是一种无连接协议，不依赖tcp/udp,直接封装在以太网帧中

arp请求时广播的，所以只能在广播域种使用，跨网端需要通过路由器【网关】来实现

细节：具体工作流程：主机A想给B发包，A查自己的arp缓存表，标识没有找到b ip地址对应的mac，就发出一个arp请求广播，所有局域网中的主机都能收到广播，只有目标ip会单播恢复自己的mac,a收到后，会将他存到自己的arp缓存表种，下次找直接就能在自己的arp表中找到了

**tcp和udp的区别**

首先tcp是面向连接的，他需要先进行三次握手才能进行数据的传输，udp不需要

tcp他是端对端的，但是udp可以是一堆一，也可以是一对多

tcp他是基于字节流的传输，udp是面向报文的传输

tcp有序列号，应答好来确保数据有序传输，udp可能会发生丢包和乱序的问题

tcp有拥塞控制流量控制等机制，他可能会在网络抖动的情况下会发生传输效率低，udp他不会出现这个问题

因此tcp可能比较慢，但是安全可靠，比较适合文件传输，网页访问等；udp比较快，可能会出现丢包等风险，比较适合视频通话，直播等

**@@@@@应用层调用 send() 到内核 TCP/IP 协议栈发送数据全过程**

当用户态调用send/write函数，这属于系统调用会先入内核，进入内核socket层，在socket层，内核会检查socket类型以及socket是否已经连接，发送的数据在缓冲区是否有空间，然后检查完毕就进入了tcp协议层，tcp会将数据根据mss大写分割成报文段，在数据前面加上tcp首部，比如说源端口，目的端后，序号，确认号等等，然后将数据放入发送缓冲区，然后就到了ip层，ip层给每个数据包前面都加上ip首部，然后到了链路层，封装以太网帧，然后调用网卡驱动的dma,把数据放到往卡的发送队列，然后网卡从队列取出数据，发送无线电波，对端网卡收帧，然后在层层上交

**@@@@@那么对于socket，面试管可能会问，你在写你的项目的时候遇到socket相关的问题了吗？**

在刚开始写socket的时候，accept/recv默认时阻塞的，导致服务端被某个客户端卡住了，然后我给socket设置了非足色结合epoll做o多路复用。还遇到了一个端口服用的问题，我当时在调是阶段，需要频繁开启服务器，他会提示我端口被 TIME_WAIT 占用的信息，解决的方法就是在bind前设置so_resureaddr,这样就可以实现端口复用

**@@@@@键入url发生什么？**

当用户在浏览器输入url并回车，浏览器会先检查缓存，要是缓存没有命中就通过dns解析得到服务器ip,然后发起tcp三次握手，要是是https还会进行tls握手，简历链结构发送http请求，请求会经过网络传输到达服务器，服务器处理后返回响应，浏览器收到响应后解析html,加载css和js,构建dom树和渲染树，最后经过布局和绘制，把页面成先到用户平面上

扩展：面时官可能追问：

当用户在浏览器输入url并回车，那么浏览器首先解析这个域名，然后现在本地硬盘的hosts文件中找看是否有和这个域名对应的ip,要是有就直接使用host文件里的ip地址，要是没有，那么浏览器会发出一个DNS请求到本地DNS服务器，本地DNS服务器会首先递归查询他的缓存记录，要是有就直接返回，要是没有，本地DNS服务器还要向DNS根服务器进行查询。根DNS服务器没有具体的域名和ip的对应关系，他负责告诉本地DNS服务器，你可以到域服务器上去查询，并把域服务器地址给他，那么本地DNS服务器继续向域服务器发出请求，请求对象是.com域服务器，.comm域服务器收到请求后，也不会直接给他域名相对应的ip,而是告诉本地服务器他的域名的解析服务器的地址，最后，本地DNS服务器向域名的解析服务器发送请求，这时就能收到一个域名和ip地址的对应关系，本地DNS不仅要把ip地址返回给电脑，还要将这对应关系存在缓存中，给下一次使用。拿到ip地址之后，浏览器会随便选择一个端口向服务器web程序80端口发起tcp连接，这个连接到达服务器后，进入网卡，然后进入内核的tcp/ip协议栈，最终到达web程序，最终通过三次握手建立tcp/ip连接，然后发起一个http请求

**dns基于udp有什么问题？，基于tcp的dns你知道吗**dot doh

**@@@@@http和https的区别**

http是明文传输协议，数据在客户端和服务端之间传输不会加密，容易被中间热门窃取，安全性较差；https在http上加了ssl/tls协议，通过对称加密，非对称加密，数字证书来保证数据的安全性；同时，https使用数字证书来验证服务器身份，反正伪造。

**https会加密url吗**

**@@@@@那么现在还会有http的使用吗？**

HTTPS 确实是主流，但在一些 **安全要求不高、受控的场景** 仍然会用 HTTP,比如，在一个完全受控的内网环境，对性能敏感又不强求加密；在本地调是或者测试阶段，为了避免证书配置复杂性，开发者也会用到http;在静态资源发恶梦发的内部链路上，为降低开销也可能用http

**@@@@@讲一下lts的4次握手？**

tls的四次握手是在tcp建立连接后进行的，首先客户端发起ClientHello,告诉服务器自己支持的协议版本，加密方法，压缩方法和一个随机数；然后服务端返回ServerHello,确认使用的协议版本，选择合适的加密算法并带上自己的证书和随机数；接着客户端验证证书合法性，，并生成一个pre-master secret预主密码，用服务端的公钥进行非对称加密后发送给服务器，服务端通过私钥解密得到预主密码，那么现在客户端和服务器都有三个随机数，双方基于三个随机数和协商算法算出会话密钥，之后的通信都是使用这个会话密钥来进行加密和解密。最后，双方各自发送 ChangeCipherSpec 和 Finished 消息，确认加密通道建立成功，此后通信就使用对称加密保证安全和效率。

那么延伸，那他用的是加密还是非加密？

在握手阶段，他是通过非对称加密加密的，因为客户段没有服务器的私钥，因此他使用服务器的公钥来进行加密，加密后服务端会会用他的私钥对pre-master secret进行解密；之后是通过对称加密，也就是此时双方都有per-master secret+随机数算出的session key【会话密钥】，然后会根据对称加密比如说是aes来进行加密，进行大量数据的传输

**@@@@@交换机？**

交换机是一种工作在数据链路层的网络设备，他通过学习MAC地址并建立MAC地址表来实现数据真的定向转发，同时交换机支持全双工通信和VLAL划分在大型网络中创用三层交换机结合路由器功能哪个时先更复杂的转发

**交换机和路由器的区别**

 **HTTP的状态码有哪些？502、504出现在什么情况？301、302的区别？**

2--【成功】：200成功；201:资源创建成功

3--【重定向】:301：永久重定向；302：临时重定向

4--【客户端错误】：400：请求语法错误；401：未认证；403：无权限；404：资源不存在

5--【服务段错误】：500：服务器内部错误；502：网关无效响应；503：服务不可用；504：网关等待下游服务超时

**HTTP无状态，那么如何保存用户登录状态？**

**@@@@@rpc和http的区别，rpc比http的优点**

http是应用层协议，定义了客户端和服务段之间请求和响应的传输规则；而rpc是一种远程调用方式，他让一可以向调用本地函数一样去调用远程服务的方法，rpc通常会基于底层传输协议并结合高效的序列化方式，相比传统的http文本传输更轻量高效

**@@@@@http1.0和http2.0的改进**

http1.0相比于http1.0主要改进有多路复用：一个tcp链接可并发多个请求，避免队头阻塞；二进制分帧；压缩头部；服务器可主动向下发资源减少延迟

**头部压缩的方式有哪些？**

http/2使用HPACK算法来实现头部压缩。他主要有两个特点：静态表和动态表：维护一张头字段表，把常见的头用索引代替，大大减少了重复传输。Huffman编码：对字符串部分进一步压缩，用更短的二进制码表示高频字符

**@@@@@tcp和udp的区别**

tcp是一种面向连接可靠的传输层协议，通过三次握手建立连接，并提供确认应答，超时重新传输，流浪控制和拥塞控制，保证数据按顺序不丢失的传输，传输过程中，每个数据段都有序号，接收方会返回确认应答（ACK），如果发送方在超时时间内没收到确认就会重传；同时 TCP 会对乱序到达的数据进行重新排序，保证按序交付；此外还通过**流量控制**（滑动窗口避免接收方被冲垮）和**拥塞控制**（慢启动、拥塞避免等算法防止网络过载）来确保传输的可靠性和稳定性。而udp是无连接的，不保证可靠传输，开销小，速度快，常用于视频通话，直播等场景

##### @@@@@tcp中序列号和应答号的理解

首先就是tcp是面向字节流的，那么他就可能有乱序问题，为了解决这个问题，发送的数据就会进行编号。序列号是对字节流里的每个字节编号，比喻应用层发了1000个字节，tcp会给每个数据包的第一个字节一个序号，后面一次递增。这样就算底层分片乱序到达，接收方有恩哪个按扎序列号进行重组。

确认号是接收方在ack里面带的一个字段，表示的是下一个期望收到的字节序号，比如确认号是501,那么就说明1-500字节都收到了，接下来要从501开始

**tcp怎样保障可靠连接的？**

首先tcp是面向连接的协议，他会先进行**tcp三次握手**之后才发送树苴

通过序列号保证接收端可以按序重组数据，同时通过校验和监测数据在传输过程中是否损坏

**确认应答机制和重传机制**，接收方在收到数据后会向发送方发送一个ack，要是发送方在超时没有收到数据，会进行超时重传

通过滑动窗口动态调整发送速度，增加流量控制

还有拥塞控制来监测网络拥塞状态，就像慢启动，拥塞避免，快重传，快恢复

**如何基于udp实现可靠传输？**

扩展：**追问quic【quick udp internet connections]，quic如何做到稳定。**

quic是google提出的，运行在udp指上的传输层协议；他虽然是基于udp,但是在udp上实现确认应答，重传机制，乱序重排可以达到和tcp一样的效果，tls的安全性，http/2.0的多路复用。首先他会将tcp和tls进行合并操作，然后就是tcp在同一个连接里多个流会阻塞队头，但是quic是在udp上面实现的多路复用，每个流独立，不会相互阻塞。而且quic连接用的是connection id 标识，不依赖四元组，所以ip变了也能保持连接

**@@@@@tcp的三次握手**

第一次客户端发送SYN包请求建立连接，第二次，服务段收到后回复SYN+ACK包，包是同意并确认客户端请求；第三次，客户端再回一个ACK包确认，连接正式建立

**@@@@@扩展：为什么需要三次握手？**

为了防止已失效的连接请求报文段突然又传送到了服务端。假设出现了这种情况，那么server发出确认，新的连接就建立，由于现在client并没有发出建立连接的请求，因此不会理财server的确认也不会向server发送数据，但server却以为新的运输连接已经建立，并一直等待client发来数据，这样，server的很多资源就白白浪费。

**tcp头格式有哪些？**

tcp头部长度最小时20字节，也就是160bit,里面主要包含：源端口，目标端口，这两个端口分别是16bit,然后就是序列号32bit,然后是确认号32bit，然后就是tcp头部长度4bit,接着保留了3bit,然后就是9bit的控制位，然后就是滑动窗口大小16bit,接着是tcp校验和16bit，最后还有16bit的紧急指针[他是URG=1有效]，最长可以拓展到60字节

控制位：SYN【建立连接】，ACK【确认收到】，FIN【终止连接】，RST【重置连接】，PSH【数据推送】，URG【数据紧急】，剩下几个好像和阻塞控制有关，但是我好就没看忘了

扩展：能详细讲一下滑动窗口码？

tcp滑动窗口是一种流量控制，主要是用来协调发送方和接收方的处理速度，保证不会因为接收方处理不过来而丢包。他这个16bit的窗口大小主要标识接收方还能接收多少字节，发送方会根据这个窗口的大小来控制发送速率。为什么叫他为滑动呢，因为接收方确认一些数据他的窗口就会往左边滑动，这样发送方就可以发送更多的数据了。发送方的滑动窗口主要有3部分，已发送已确认的数据，那证明接收方已经成功接收到了，那么就可以从发送缓冲区释放；已发生未确认的数据，发送方已经发送但是还没有收到接收方的ack,此时必须暂时保留在发送缓冲区，防止需要重传；未发送但在窗口范围内的数据，可以立即进行发送的数据。滑动窗口一般是和拥塞控制结合使用

滑动窗口 = 流量控制（接收方能力）

拥塞控制 = 避免网络过载（链路能力）

讲一下校验和

它主要的作用就是保证tcp报文在传输过程中数据的完整性。发送方在发送数据前，他会把tcp头部，数据的伪首部【包含源ip地址，目标ip地址，协议号和tcp长度】做16为的反码和，结果放入到校验和字段，然后接收方接收到数据后，会在做一次相同的运算，要是结果不全是1,那么就证明传输来的报文有问题

把数据按 16 位相加，溢出回卷，最后取反

**@@@@@第三次握手ack丢失？**

**@@@@@tcp的四次回收**

首先，客户端发送FIN包给服务端表示我没有数据要发了，然后服务器会ACK表示收到，但是他可能还有数据没发完，等服务器发完数据后，他在向客户端发送FIN包表述我也没有数据要发了，最后客户端再回ACK确认，连接正式关闭。

**可能会三次挥手吗，什么情况？**

他的标准流程一般是四次挥手，因为每一方向另一方向关闭都是独立的，三次挥手有以下情况：

第一方关闭连接之后另一方没有数据要发送。比如说客户端发送了一个fin,然后服务端回了一个ack，此时服务端时没有数据要发送给客户端的，所以客户端就自动进行关闭，也就是进行了两次交互

还有就是半关闭优化：也就和上面一样，就把主动没有数据改成被动没有数据发送，关闭他的fd

**@@@@@为什么建立连接是三次握手，而关闭连接却是四次挥手呢？**

这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。

tcp如何保证可靠传输，也是上面的问题噢

**@@@@@长连接和短连接有什么区别吗？**

他们的主要区别在连接的维持时间上和资源消耗上。长连接是在客户端和服务端简历一次tcp连接后保持一段较长的时间，在这器ian可以复用这个连接发送多次请求，这样可以减少频繁建立连接和关闭连接带来的开销，提高网络效率，适合频繁通信的场景，但是长连接会占用服务器资源，如果连接数过多，可能会消耗大量内存和文件描述符。端连接也就是每次请求都建立新的连接，请求完成后就会断开，优点是链接端，占用资源少，但是要是连接频繁的话会带来额外的开销和延迟，比较适合偶发性场景

 **TCP半连接，全连接，建立完成，哪个阶段最占用内存呢**

我觉得最占用内存的时全连接和简历完成之后，首先半连接他是在服务端收到客户端SYN之后，这个阶段还没又分配到完整的socket结构，占用内存较少；在全连接队列的时候，此时三次握手已经完成了，队列俩面存有完整的socket控制快和tcp缓冲区，占名比半连接明显增加；在建立完连接之后，也就是accept()之后，连接成为一个真正的fd,占用资源我感觉和全队列应该差不多

**@@@@@一个ip段，有四个ip地址，有几个不可用?**

在一个子网里面，全为0的主机号是网络地址，不能分配给主机，还有一个是全为1的主机号，他是广播地址，不能分配给主机，所以一个子网里面，可用地址树是总地址数-2

举例说明：

**网络IO的流程**

一个/29的网络，那么他的子网掩码是：11111111.11111111.11111111.11111000，子网掩码的作用主要是为了判断一个ip是否数以一个子网，要是属于一个子网里面，那就可以进行通信了

假设一个ip:192.168.1.2-------------11000000.10101000.00000001.00000010

​             掩码：255.255.255.248--11111111.11111111.11111111.11111000

​             进行与操作--------------------11000000.10101000.00000001.00000000  → 192.168.1.0



假设子网是192.168.1.0/29,这个子网，先把他的网络号写出来11000000.10101000.00000001.00000   （29 位）

​																				  s               这后面把主机号加上

000 001 010 100 011 110 101 111

a:0        1     2      4     3      6     5       7

那么可用的就是000和111之间的

也就是192.168.1.1/2/3/4/5/6【这里比较好算是因为网络好最后小数点那5位是0】算法：. . . .s+a

首先说一下/后面的数字可以是/0-/32,这里后面的数字主要表示的是一共是32位【为什么是32位】，把数字前面全部设置成1,后面全部设置成0,后面的表示的是主机号，也就是一共有2的32-数字个主机号

**讲讲电脑里的网卡**

**@@@@@半双工和全双工？**

半双工：同一时间只能单向通信

全双工：同一时间可以双向同时通信

**什么是四元组**

源ip地址，源端口号，目的ip地址，目的端口号

**@@@@@MTU是什么？为什么设置为1500字节**

MTU也就是maximum transmission unit,也就是网络层一次能传输的最大数据包的大小，不包括链路层的头部；他的作用是控制每个数据包的大小，避免数据包过大导致的分片，从而导致的传输效率降低以及丢包风险的增加；以太网默认的MTU是1500字节，这个值能一直保持也不是没有他的道理的，肯定兼顾了传输效率和分片开销。

常见的网络攻击方式

**TCP 中何时会出现 RST 报文？**

rst报文标识tcp连接出现异常，需要强制复位连接。

比如：

向不存在的端口发送数据：客户端connect到服务器一个没有间题监听的端口，服务器会直接返回一个rst报文

一方已经close后，收到数据会返回rst

应用层调用setsockopt设置立即关闭套接字，此时内核不会走四次挥手，直接发送rst

**已建立连接时客户端突然断电 / 进程崩溃会怎样？**

当客户端突然崩溃或者断电，tcp连接不会里面断开，因为没有fin或者rst,因此服务器刚开始会保持establiehed状态，最后会通过超时崇川才能监测到连接失效，之后服务端会主动关闭自己的连接

ai:

当客户端已经建立连接后突然断电或进程崩溃时，TCP 连接不会立即断开。
 因为此时客户端来不及发送 **FIN**（正常关闭）或 **RST**（异常重置） 报文。

服务器端的 TCP 连接会**继续保持在 ESTABLISHED 状态**，认为连接仍然存在。
 在此期间，若服务器发送数据但一直收不到 ACK，应答超时后会进行多次重传。
 当重传次数达到上限，或启用了 **TCP Keepalive / 应用层心跳检测** 时未收到响应，
 内核或应用层就会判断连接已失效，然后**主动关闭连接**。

**ping的整个流程？**

ping是基于icmp的网络连通测试工具，用来监测目标主机是否可达，网络延迟的问题，主要工作在网络层。比如你现在ping  www.qq.com,那么首先通过dns将域名解析成ip地址，【因为他是工作在ip层的，无需进行Tcp的三次握手】，然后构造icmp报文，ip头部后面会跟着icmp头部，之后会将这个报文通过arp协议获取目标ip的mac地址，然后通过网卡发送出去。

对方主机收到 icmp echo request后，内核协议栈会时别出他是icmp请求，会同遭icmp echo reply报文通过原路经返回给源主机

ai版本：

“ping 是基于 ICMP 协议的网络连通性测试工具，工作在网络层。
 执行 `ping www.qq.com` 时，首先通过 DNS 将域名解析为 IP 地址。
 ping 构造 ICMP Echo Request 报文，在发送前通过 ARP 获取目标 IP 的 MAC 地址，然后由网卡封装成以太网帧发送出去。
 目标主机收到请求后，内核网络栈识别为 ICMP 请求，并回复 ICMP Echo Reply 报文。
 源主机收到应答后计算往返时延（RTT），判断网络是否连通。
 整个过程基于 ICMP，不经过 TCP 或 UDP。”

**socket不用端口的时候能不能进行数据传输？**

在socket通信种，端口号是传输协议的标识，用于取分同一主机上的不同进程，在我们创建tcp或者udp socket时，系统必须为他分配端口号，否则无法完成传输层的复用和路由。但是要是时原始套接子或者数据链路层套接子，他们直接工作在ip层或链路层发送数据帧，不依赖tcp/udp,因此不需要端口号，比如说ping,他是基于icmp工作在网络层的，用的就是原始套接子，不存在端口

ai:

在 socket 通信中，端口号是**传输层协议（TCP、UDP）**用来区分同一主机上不同进程的标识。
 当我们创建 TCP 或 UDP socket 时，系统必须为它分配端口号，否则无法完成传输层的复用和路由。

但如果使用的是 **原始套接字（Raw Socket）** 或 **数据链路层套接字（比如 AF_PACKET）**，它们直接工作在 **IP 层或链路层**，不依赖传输层协议，因此不需要端口号。

举个例子：
 `ping` 命令就是基于 **ICMP 协议** 的，它工作在网络层，使用的就是原始套接字，因此根本不存在端口号的概念。

**vlan和vxlan？**

vlan是一种二层网络隔离技术，通过在以太网帧李家802.1Q的vlan tag来区分不同的广播域，他的id只有12为，也就是最多有4096个网络，而且只能工作在数据链路层，无法跨越到第三层

vxlan是在网络层，他会把整个数据链路层封装在udp报文，通过三层网络建立隧道，让不同字网的主机看起来好向在一个二层网络里面，他是用24位代替了之前的12位id,可以构建更多网络，对云原省方面比较又好

ai:

VLAN 是一种二层网络隔离技术，它通过在以太网帧里加入 802.1Q 的 VLAN Tag 来区分不同的广播域。
 它的 ID 只有 12 位，所以最多可以支持 4096 个网络（实际可用 1~4094），并且只能工作在数据链路层，不能跨越三层网络。

VXLAN 是一种基于三层网络的隧道技术，它会把整个二层的以太网帧封装到 UDP 报文中（端口号通常是 4789），
 通过三层网络建立隧道，让不同子网的主机看起来像是在同一个二层网络里。
 VXLAN 使用 24 位的 VNI 来取代 VLAN 的 12 位 ID，可以支持约 1600 万个虚拟网络，非常适合云计算和多租户环境。

网络为什么不能从tcp层直接到数据链路层吗？

**相同的服务端ip和端口可以连多个客户端的ip和端口吗？相同的客户端ip和端口可以连多个服务器的ip和端口吗？端口是哪来的？**

tcp连接时通过四元组来唯一标识的

，相同的服务器ip+端口，可以同时连接多个不同的客户端；但是相同的客户端ip+端口，只能同时连接一个服务器ip+端口，这是为了避免冲突

端口是操作系统内核分配的，服务器一般监听固定的端口，客户端的多口一般是内核自动临时分配的











