redo log ,undo log,binlog傻傻分不清？

作用：

undo log:回滚日志，实现了事务的原子性，主要用于事务回滚和mvcc

redo log:重做日志，实现了事务的持久性，主要用于崩溃恢复

binlog:归档日志，主要用于主从复制和数据备份

实现方法：

**事务回滚：**

在你进行一个事务，比如说插入删除操作前，都会将更新前的数据放入undo log里面，要是在事务提交前崩溃了，也就是没有进行提交，那么他会通过undo log来进行日志的回滚

举例：

假设我们在做数学题，目前这道题我们用复杂的方法已经做出来了，但是老师让找出更简单的方法，目前我想出来了，但是不知道可以执行成功不，因此我要把我之前的过程保存着，然后在算，要是失败了，还可以用之前的进行回滚

每次产生的undo log他都有一个roll_pointer指针和trx_id事务id,通过指针将这些undo log版本串联起来，每个undo log里面的id标记该记录时通过哪个事务id修改的

**通过readview+undo实现mvcc:**

对于读已提交和可重复读，他们的快照读都是通过redaview+undo log实现的，就是生成的时机不同，读以提交是一个事务在执行期间每次select的时候都会生成一个readview,那么在一个事务进行读期间就可能出现前后两次读一个数据出现不一致的情况，也就是出现了不可重复读；那么解决方式就是可重复读，也就是在事务执行期间无论你进行了多少次select,就只有第一次生成了readview,那么就保证了事务前后读到的数据一致性

大概说一下他的比较流程：比如你对于这一行数据的每一次插入删除更新都会记录成undo log串成一条链，那么当你进行快照读的时候，这个readview就包含了min_id[最小id]和max_id[最大id],要是最近的这个undo log里面的id小于min_id,那么就可读，要是大于max_id，就不可读，要是在mins_id和max_id返回里面，就看他是否包含，要是包含就不可读，要是不包含就可读，要是这个undo log不满足条件，就通过pointer继续像前进行寻找，知道找到第一个满足的就可以返回了

undo log需要进行刷盘吗，他是怎样进行持久化的？

在你进行一个写操作的时候，他会在执行前生成undo log把这条生成的命令放在buffer pool里面，并将这个页标记为脏页，在事务进行提交是，undo log会被强制进行刷盘

redo log:

因为每次进行写操作他会先将修改的数据写入到buffer pool里面，并将他标记为脏页，但是buffer log是基于内存的，要是在事务提交后只是写入到了内存，那么要是断电或者宕机了会存在数据丢失的风险，那么为了避免出现这种情况，就出现了wal机制

在你进行写操作是，首先会将操作写入到redo log，然后在进行之后的操作

因此整个流程是这样的，在你准备修改一个数据时，他会先生成一个undo log将这个旧值存起来，然后在你修改的时候，会将数据页的物理修改通过wal写入到redo log里面，然后你修改了数据准备提交时，他会将buffer pool里面的undo log页和redo log页进行刷盘操作

在出现崩溃的时候，他会先读取redo log,通过redo log来进行恢复，通过undo log来进行扫面，要是事务没有提交就进行相反的操作来实现日志的回滚

内部实现方式：

redo log主要由两个文件，logfile0和logfile1，先写0然后写1他们时以顺序的方式进行写入，内部主要维护了两个指针，write指针和check指针，write到check之间是待写入的，check到write之间是待刷盘的，以为他是采用循环写的方式，因此要是并发操作比较多的话应该把redo log文件设置的大一些，每次事务修改的树将进行了落盘之后，check指针就会顺时针进行移动

undo log和redo log都是在innodb存储引擎生成的,server生成了binlog

### 正确的写入顺序（单事务写操作）：

1. **执行前生成 Undo Log**：

   事务开始，修改数据前先将旧值写入 `Undo Log Buffer`（内存），用于回滚和 MVCC。

2. **修改数据页 + 记录 Redo Log**：

   - 直接修改 `Buffer Pool` 中的数据页（标记为脏页）。
   - 同时将数据页的物理修改（如 “某页某偏移量从 A 变 B”）写入 `Redo Log Buffer`（内存）。

3. **事务提交阶段：写 Binlog → 刷 Redo Log → 刷 Undo Log**：

   - **第一步：写 Binlog**：将事务的逻辑操作（如 `UPDATE table SET ...`）写入 `Binlog Cache`，然后刷盘到 Binlog 文件（Server 层操作）。

   - **第二步：刷 Redo Log**：将 `Redo Log Buffer` 中的内容强制刷盘（持久化到 Redo Log 文件），此时事务进入 “准备提交” 状态。

   - **第三步：刷 Undo Log**：将 `Undo Log Buffer` 中的内容强制刷盘（持久化到 Undo Log 文件）。

   - **最后**：事务提交成功，返回客户端确认。

     为了避免出现binlog写，redo log没写或者redo log写，binlog没写，那么就出现了两阶段提交来解决两个日志逻辑不一样的问题

     每个阶段由协调者和参与者共同完成

     主要是内部XA事务，由binloog当作协调者，存储引擎当作参与者

     

     